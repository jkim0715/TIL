# R 데이터 분석

## 왜 R 인가?

R은 데이터 분석을 위한 통계 및 그래픽스를 지원하는 자유 소프트웨어 환경, 오픈소스.

1. 통계 분석 언어인 S에 기반을 두고 있음.

2. Data Mining, 같은 필드가 인기가 높을 때 인기가 많아지기 시작.

3. R은 컴퓨터 언어이자 다양한 패키지의 집합.

    다양한 라이브러리가 하루에도 수백개씩 생기곤 함.

4. 데이터 분석을 해낼 수 있음 ( 통계, 기계학습, 금융, 생물정보학, 그래픽스 등)

5. 통계를 기반으로 한 데이터 분석 

6. CRAN(http://cran.r-project.org/web/views/) 에서 다양 한 패키지들을 다운로드 받을 수 있음

7. R은 자바연동, 빅데이터 연동이 쉽다. (RHIVE를 이용하여 하이브 환경에서 R사용)

8. 원래 파이썬이 통계 기능쪽에서 R보다 딸렸는데 요즘은 여러가지 통계 라이브러리가 추가되었음

9. R를 쓰는 이유는 통계 패키지를 활용할 수 있기 때문이다.

I. R설치하기

- http://www.r-project.org/
- Windows 용 다운로드 
- default값으로 설치



II. Rstudio

- IDE 툴 (Integrated  Development Environment)

- 이클립스 같은게 IDE 툴 임.
- rstudio.com 에서 다운로드
- free version download - Rstudio 1.2.1335 -Windows 7+(64bit)
- R이랑 연동해서 돌아감 



III. 활용

file - new project - new Directory - new project - (폴더 이름이랑 경로 설정하고 create)r

왼쪽 상단 + 눌러서 R Script 누르면 코드 입력 창 같은게 나오는데 이게 자바 같은거

1. run은 라인별 실행
2. source는 전체 실행 
3. console창은 리눅스 터미널과 명렁어 가 비슷하다

패키지 활용하기

패키지 다운로드

install.packages("randomForest")

패키지 저장 경로 :  C:\Program Files\R\R-3.6.1\library 밑에 저장됨



패키지 사용하기 

```R
library(randomForest)
```

마치 자바에서 외부라이브러리를 Import 해서 사용하는 것 과 같이 RScript 맨 윗부분에 작성





## 데이터 타입

I. 변수

변수이름 규칙

- 변수명 : 알파벳, 숫자, _(언더스코어),.(마침표)로 구성.  -(하이폰)은 사용 할 수 없다.
- . 으로 시작한다면 뒤에 숫자가 올 수 없다.

변수 값 할당

 = 대신 <- (화살표)를 씀

=은 명령 최상위 수준에서만 사용



함수 호출 시 인자 지정

R의 함수인자는 위치 또는 이름으로 지정 가능.

```
foo(a, b, c=1, d=2)

foo(1, 2, 3, 4)
foo(3, 4)
```

함수선언시 값을 넣어주면 default 값으로 들어가서 따로 c와 d를 인자로 전달하지않으면 각각 1 , 2로 지정되어 호출함.



--본격적인 R에서의 변수 타입--

R에서 데이터 타입의 기본은 벡터(Vector)



###  스칼라 Scalar

- 숫자

- NA (Not Available)

  연산시 배제해야 함이 맞음.

   is.na 를 활용하여 ( NA가 저장되어 있으면 TRUE 아니면 FALSE를 리턴함)

- NULL

  변수가 초기화 되지 않았을 때 사용 NA와 구분하여 사용.

  대문자 NULL로 써야 함.

- 문자열

- 진리값

  

팩터 (Factor) 

- 범주형 데이터 자료를 표현하기 위한 데이터 타입.

- ```
  sex <- factor("m",c("m","f"))
  
  sex
  [1] m
  
  Levels: m f
  ```

  



### 벡터

다른언어에서 배열 개념

Example)

```javascript
#배열 선언  score
score <- c(100,90,80);  

#배열 컬럼지정
names(score) <-c("lee","kim","han");

#score 출력
print(score);

#배열의 첫번째 출력 (컬럼이랑 같이 출력 됨)
print(score[1]);

#배열 안 합산값 출력
print(sum(score));

#컬럼 "lee"의 값 출력
print(score["lee"]);

#1~10까지 배열 v1으로 선언
v1 <- c(1:10);

#배열 첫번째 값 출력
print(v1[1]);

#배열 v1에서 열번째 값 뺴고 출력
print(v1[-10])

#배열 인자값 카운트
print(NROW(v1))
print(length(v1))

#5~8번쨰 인자값 출력
print(v1[5:8]);

```



두개 이상일 떄는 무조건 **c (vector)**를 이용해야 한다.



벡터 연산





### 리스트 

R에서의 리스트는 Key Value를 의미함



### 행렬 (Matrix)

대부분의 데이터는 정방행렬 형태일 것.

행렬의 연산

한가지 타입의 데이터만 들어감

```javascript
ma <- matrix(c(1:6), nrow=3)
print(nrow(ma))
print(ncol(ma))
```







### 배열(Array)

다차원 데이터 

안함.



### **데이터 프레임 (Data Frame)**

- 다양한 타입의 데이터가 들어간다.

처리할 데이터를 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 데이터 프레임의 각 열에는 관측값의 이름이 저장되고, 각 행에는 매 관측 단위마다 실제 얻어진 값이 저장된다.

| 성명   | 국어 | 영어 |
| ------ | ---- | ---- |
| 홍길동 | 80   | 94   |
| 김길동 | 97   | 100  |
| 박길동 | 85   | 97   |

 데이터 프레임은 R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.



#### 데이터 프레임 생성

- data.frame : 데이터 프레임을 생성한다.

```javascript
df1 <- data.frame(x=c(1:5),y=c(5:9),z=c(10:14))
print(df1)
print(df1$x)
print(df1[1,])
print(df1[,2])
print(df1$x[3])
print(df1[3,1])
print(df1["x"])

print(df1)
df2 = df1[c(2:5),c(2:3)]
print(df2)
```

- str : 임의의 R 객체의 내부 구조(structure)를 보인다.

```javascript
df1 <- data.frame(
  "lee" = c(90,99,89,87),
  "kim" = c(91,98,81,86),
  "han" = c(92,97,82,85),
  "jun" = c(93,96,83,84),
  "goo" = c(94,95,84,83),
  "grade" = c("A","B","C","D")
)

print(df1)
# avg per student
each1 <- c(mean(df1$lee),
           mean(df1$kim),
           mean(df1$han),
           mean(df1$jun),mean(df1$goo))
print(each1)
print(mean(each1))

# avg per subject

each2 <- c(sum(df1[1,]),
          sum(df1[2,]),
           sum(df1[3,]),
           sum(df1[4,]))
print(each2)  

str(df1)

#change original value to new value
df1$lee <- c(0,0,0,0)
#able to append new col
df1$hong <- c(100,100,100,100)
```

```javascript
df1 <- data.frame(
  a=c(1:4),
  b=c(5:8),
  c=c(9:12),
  d=c("A","B","A","B")
)
rownames(df1) <- c("aa","bb","cc","dd")
print(df1)

df2 <- df1[,-4]
print(df2)

print(df2[1,3])
print(df2$a)
print(mean(df2$a))
#need to convert data.frame to numeric in order to get the mean
print(mean(as.numeric(df2[1,])))

df3 <- df1[c(1:4),c(1:3)]
print(class(df3[1:2]))

df4 <- df1[,c("c","b")]
print(df4)

View(df3)


```



### 타입판별

데이터를 처리하기 위해 여러 함수를 호출하다 보면 반환된 결과의 타입이 무엇인지 분명하지 않을 때가 많다. 이 경우 다음 함수들을 사용하여 데이터 타입을 손쉽게 판단할 수 있다.

▼ **표 2-23** 데이터 타입 판별 함수

| 함수             | 의미                                     |
| ---------------- | ---------------------------------------- |
| class(x)         | 객체 x의 클래스                          |
| str(x)           | 객체 x의 내부 구조                       |
| is.factor(x)     | 주어진 객체 x가 팩터인가                 |
| is.numeric(x)    | 주어진 객체 x가 숫자를 저장한 벡터인가   |
| is.character(x)  | 주어진 객체 x가 문자열을 저장한 벡터인가 |
| is.matrix(x)     | 주어진 객체 x가 행렬인가                 |
| is.array(x)      | 주어진 객체 x가 배열인가                 |
| is.data.frame(x) | 주어진 객체 x가 데이터 프레임인가        |

다음은 벡터, 행렬, 데이터 프레임에 class( )를 적용하여 클래스를 구하는 예를 보여준다.

```
> class(c(1, 2))
[1] "numeric"
> class(matrix(c(1, 2)))
[1] "matrix"
> class(data.frame(x=c(1, 2), y=c(3, 4)))
[1] "data.frame"
```

class( )는 문자열로 데이터 타입을 반환하는데, 이 예에서는 숫자형 벡터에 numeric, 행렬에 matrix, 데이터 프레임에 data.frame을 반환했다. 특히 class( )에 벡터를 인자로 전달한 경우 numeric이 반환되었는데, 이는 벡터에 저장된 값이 숫자기 때문이다. 벡터에 저장된 데이터 타입에 따라 이 값은 logical, character, factor 등이 될 수 있다.

데이터 타입은 str( )로도 확인해볼 수 있다. 다음 예에서 벡터와 행렬의 결과가 유사해 보이지만 벡터의 경우 차원이 [1:2](1차원에 값이 2개)라고 표시되어 있는 반면, 행렬은 차원이 [1:2, 1](2차원이고 2행 1열)로 표시되어 있는 점이 다르다.

```
> str(c(1, 2))
num [1:2] 1 2
> str(matrix(c(1,2)))
num [1:2, 1] 1 2
> str(list(c(1,2)))
List of 1
$ : num [1:2] 1 2
> str(data.frame(x=c(1,2)))
'data.frame': 2 obs. of 1 variable:
$ x: num 1 2
```

R의 데이터 타입에는 타입 이름이 ‘typename’이라 할 때 ‘is.typename( )’ 형태의 함수가 존재한다. 이 함수들은 주어진 객체 x가 ‘typename’ 데이터 타입에 해당하는지를 판별하는 용도로 사용한다. 이러한 함수의 예로 팩터인지 여부를 알려주는 is.factor( ), 숫자를 저장한 벡터인지를 알려주는 is.numeric( ), 문자열을 저장한 벡터인지를 알려주는 is.character( ) 등을 들 수 있다. 다음에 몇 가지 함수의 사용 예를 보였다.

```
> is.factor(factor(c("m", "f")))
[1] TRUE
> is.numeric(1:5)
[1] TRUE
> is.character(c("a", "b"))
[1] TRUE
> is.data.frame(data.frame(x=1:5))
[1] TRUE
```

‘is.typename( )’ 형태의 함수 목록은 표 2-23을 참조하기 바란다.

### 타입변환

R의 형 변환은 암시적으로 발생할 수 있고, 때에 따라 형 변환이 전혀 예상치 않은 곳에서 일어난다. 예를 들어, 데이터 프레임 d에 2개 컬럼이 있고 각 컬럼의 데이터 타입이 numeric(숫자를 저장한 벡터)이라고 가정하자. 이때 d[, 1]은 첫 번째 컬럼의 데이터를 데이터 프레임이 아닌 numeric(즉, 벡터)으로 반환한다. d에 대한 연산의 결과가 데이터 프레임이 아니라 numeric이라는 점은 사용자를 당황하게 할 수 있는 점이며, 이러한 변환을 피하고 싶다면 drop=FALSE를 지정해야 한다. 또는 파일에서 문자열을 불러들였을 때 data.frame( )으로 데이터 프레임을 생성하면서 stringsAsFactor=FALSE를 지정하지 않으면 문자열이 character(문자열 벡터)가 아니라 팩터가 된다.

이와 같은 암시적 형 변환에 대비하기 위해 모든 의심스러운 함수 호출 뒤에는 ‘2.9 타입 판별’ 절에서 설명한 str( ), class( )를 사용해 현재 사용하는 데이터가 올바른 데이터 타입인지 계속 확인할 필요가 있다.

반면 타입을 강제로 변환하고자 할 때도 있을 것이다. 문자열 벡터를 팩터로 변환하는 경우 등이 그 예다. 이러한 변환을 하는 한 가지 방법은 타입 이름이 ‘typename’이라 할 때 ‘as.typename( )’이라는 함수를 사용하는 것이다. 다음에 관련 함수의 목록을 보였다.

▼ **표 2-24** 데이터 타입 변환 함수

| 함수             | 의미                                        |
| ---------------- | ------------------------------------------- |
| as.factor(x)     | 주어진 객체 x를 팩터로 변환                 |
| as.numeric(x)    | 주어진 객체 x를 숫자를 저장한 벡터로 변환   |
| as.character(x)  | 주어진 객체 x를 문자열을 저장한 벡터로 변환 |
| as.matrix(x)     | 주어진 객체 x를 행렬로 변환                 |
| as.array(x)      | 주어진 객체 x를 배열로 변환                 |
| as.data.frame(x) | 주어진 객체 x를 데이터 프레임으로 변환      |

또 다른 타입 변환 방법은 factor( ), data.frame( ) 등과 같이 데이터를 생성하는 함수에 다른 타입의 데이터를 인자로 넘겨주는 것이다. 이 경우 필요에 따라 형 변환이 수행된다.

as.typename( )’ 유형부터 살펴보자. 다음은 “a”, “b”, “c”가 저장된 문자열 벡터를 팩터로 변환했다가 다시 벡터로 변환하는 예다.

```
> x <- c("a", "b", "c")
> as.factor(x)
[1] a b c
Levels: a b c
> as.character(as.factor(x))
[1] "a" "b" "c"
```

다음은 행렬을 데이터 프레임으로 변환하는 예다.

```
> x <- matrix(1:9, ncol=3)
> as.data.frame(x)
  V1  V2  V3
1  1   4   7
2  2   5   8
3  3   6   9
```

또는 factor( ), matrix( ), data.frame( ) 등과 같은 데이터 생성 함수에 곧바로 다른 타입을 넘겨 형 변환을 할 수도 있다. 다음은 행렬을 데이터 프레임으로 변환하기 위해 matrix( )의 결과를 data.frame( )에 곧바로 넘긴 예다.

```
> (x <- data.frame(matrix(c(1, 2, 3, 4), ncol=2)))
  X1 X2
1  1  3
2  2  4
```

다음은 리스트를 data.frame( )에 넘겨 데이터 프레임으로 변환한 예다.

```
> data.frame(list(x=c(1, 2), y=c(3, 4)))
  x y
1 1 3
2 2 4
```

두 가지 방법이 모두 가능하다면 그 차이가 무엇일까? ‘as.typename( )’은 표현이 명확하고 간략하지만 경우에 따라 지원하는 변환의 정도가 약하다. 예를 들어, c(“m”, “f”)의 벡터를 as.factor( )로 변환하는 경우를 생각해보자. 이 경우 f가 알파벳 순서상 m보다 앞서므로 as.factor(c(“m”, “f”))의 결과에서 팩터의 레벨은 “f m”으로 정해진다. 팩터의 레벨을 “m f”로 하려면 어떻게 해야 할까? as.factor( )는 변환할 데이터 이상의 인자를 받지 않으므로 as.factor( )를 사용할 때 팩터의 레벨을 “m f”로 지정할 수 있는 방법이 없다. 팩터 레벨의 순서를 “m f”로 하고 싶다면 다음과 같이 factor( ) 함수를 써야 한다.

```
> as.factor(c("m", "f"))
[1] m f
Levels: f m
> factor(c("m", "f"), levels=c("m", "f"))
[1] m f
Levels: m f
```

따라서 상황에 따라 두 가지 방법을 모두 사용해보고 help(함수명)으로 볼 수 있는 도움말을 참고해 적절한 방식을 찾아 형 변환을 수행해야 한다.



## R 프로그래밍

### R의 특징

R 프로그래밍은 다른 언어와 상당히 유사해 예시 코드를 참조하면 쉽게 프로그래밍 방법을 배울 수 있다. 그러나 R에는 다른 언어와 몇 가지 특징적인 차이점이 있어 이들을 잘 이해할 필요가 있다.

첫째는 데이터를 다루는 방법이다. 다른 프로그래밍 언어에서는 흔히 for 문을 사용해 데이터를 한 행씩 읽어들여 처리한다. 하지만 R에서는 전체 데이터를 한 번에 다루는 벡터 연산을 더 자주 사용한다.

둘째는 결측치NA다. R에는 초기화되지 않은 변수에 저장하는 NULL 외에도 관측 또는 기록되지 않은 데이터를 표시하기 위한 NA가 있다. 따라서 코드에서 NA를 제대로 구분해서 처리하지 않으면 원하는 결과를 얻지 못할 수도 있다. 

셋째는 객체의 불변성이다. 대부분의 R 객체는 그 값을 수정할 수 없다. 따라서 문법적으로 객체의 데이터를 수정하고 있다고 보이는 코드에서도 실제로는 해당 부분의 값이 수정된 새로운 객체가 생성된다.



### 흐름 제어(조건문과 반복문)

이 절에서는 프로그래밍의 필수 요소가 되는 조건문과 반복문(if, for, while, repeat)에 대해서 알아본다. 문법은 대부분의 언어와 유사하므로 어렵지 않게 익힐 수 있을 것이다. switch 문도 존재하지만 잘 사용하지 않으며, 대신 조건문을 많이 사용한다.



#### if

먼저 조건에 따라 코드의 수행 여부를 결정하는 if 문에 대해 살펴본다. 다음은 if 문의 문법 구조를 정리한 표다.

▼ **표 3-1** if 문법

| 문법                                                         | 의미                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `if (cond) {    cond가 참일 때 실행할 문장 } else {    cond가 거짓일 때 실행할 문장 }` | 조건 cond가 참, 거짓인 경우에 따라 {} 블록을 실행한다. 필요한 경우 else 블록을 지정할 수 있다. |

다수의 TRUE, FALSE 데이터를 한 번에 처리한다면 ifelse( ) 함수를 고려할 수 있다.

▼ **표 3-2** ifelse( ) 함수

| ifelse : 주어진 test 값에 따라 yes 또는 no 값을 반환한다.    |
| ------------------------------------------------------------ |
| `ifelse(  test, # 참, 거짓을 저장한 객체  yes, # test가 참일 때 선택할 값  no # test가 거짓일 때 선택할 값 )`test에 다수의 TRUE, FALSE가 저장되어 있을 때 TRUE에 대해서는 yes 값을, FALSE에 대해서는 no 값을 선택하여 반환한다. |

조건문 if의 예를 살펴보자.

```javascript
> if ( TRUE ) {
+    print("TRUE")
+    print("hello")
+ } else {
+    print("FALSE")
+    print("world")
+ }
[1] "TRUE"
[1] "hello"
```

위 코드의 결과는 “TRUE”, “hello”다.

ifelse( )를 사용하면 if 문을 다수의 데이터에 한 번에 적용하는 연산이 가능하다. 다음은 1, 2, 3, 4, 5에서 값이 짝수일 경우 “even”, 홀수일 경우 “odd”를 출력하는 예다.

```javascript
> x <- c(1, 2, 3, 4, 5)
> ifelse(x %% 2 == 0, "even", "odd")
[1] "odd" "even" "odd" "even" "odd"
```



#### 반복문

R의 반복문에는 for, while, repeat 문이 있다. 다음은 이 세 가지 문법을 설명한 표다.

▼ **표 3-3** 반복문의 문법

| 문법                                            | 의미                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `for (i in data) {   i를 사용한 문장 }`         | data에 들어 있는 각각의 값을 변수 i에 할당하면서 각각에 대해 블록 안의 문장을 수행한다. |
| `while (cond) {   조건이 참일 때 수행할 문장 }` | 조건 cond가 참일 때 블록 안의 문장을 수행한다.               |
| `repeat {   반복해서 수행할 문장 }`             | 블록 안의 문장을 반복해서 수행한다. repeat은 다른 언어의 do-while에 해당한다. |

반복문 내 블록에서는 break, next 문을 사용해 반복의 수행을 조정할 수 있다.

**•** **break** : 반복문을 종료한다.

**•** **next** : 현재 수행 중인 반복문 블록의 수행을 중단하고 다음 반복을 시작한다.

다음 코드에서 for 문은 변수 i가 주어진 벡터에 있는 1, 2, 3, …, 10을 차례로 출력한다.

```javascript
> for (i in 1:10) {
+    print(i)
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

다음 while 문은 1부터 10까지 숫자를 출력하기 위해 변수 i의 값을 10과 비교하면서 print( )하는 예다.

```javascript
> i <- 1
> while (i <= 10) {
+    print(i)
+    i <- i + 1
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

while 문에서 next를 사용해 짝수만 출력해보자. 값이 짝수인지 확인하는 데는 나머지 연산자 %%를 사용했다.

```javascript
> i <- 0
> while (i <= 9) {
+    i <- i + 1
+    if (i %% 2 != 0) {
+       next  # print()를 실행하지 않고 while 문의 처음으로 감
+    }
+    print(i)
+ }
[1] 2
[1] 4
[1] 6
[1] 8
[1] 10
```

다음은 repeat을 사용해서 1부터 10까지 값을 출력한 예다. repeat 문에서 조건을 지정하려면 블록 내부에서 if 문으로 조건을 확인하고 break로 빠져나오도록 해야 한다.

```javascript
> i <- 1
> repeat {
+    print(i)
+    if (i >= 10) {
+       break
+    }
+    i <- i + 1
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```



###  연산

#### 수치 연산

지금까지 암시적으로 사용한 사칙 연산(+, -, *, /)을 포함한 수치 연산에 대해 알아보자. 사칙 연산은 다른 언어와 크게 다르지 않지만 약간의 문법적 차이가 있다. 다음 표에 연산자와 함수를 정리했다.

▼ **표 3-4** 수치 연산자와 함수

| 연산자와 함수          | 의미                                                   |
| ---------------------- | ------------------------------------------------------ |
| +, -, *, /             | 사칙 연산                                              |
| n %% m                 | n을 m으로 나눈 나머지                                  |
| n %/% m                | n을 m으로 나눈 몫                                      |
| n^m                    | n의 m승                                                |
| exp(n)                 | e의 n승                                                |
| log(x, base=exp(1))    | logbase(x). 만약 base가 지정되지 않으면 loge(x)를 계산 |
| log2(x), log10(x)      | 각각 log2(x), log10(x)를 계산                          |
| sin(x), cos(x), tan(x) | 삼각 함수                                              |

위 연산자는 다른 프로그래밍 언어와 크게 다른 점은 없지만, 다음 절에서 다룰 벡터 연산을 사용해 다수의 데이터에 연산을 한 번에 수행할 수 있다는 점은 알아둘 만하다. 다음은 1, 2, 3, 4, 5 각각에 2를 곱한 뒤 1을 더한 예다. 각 숫자를 개별적으로 연산하는 것이 아니라 벡터에 통째로 연산자를 적용하고 있음을 눈여겨보기 바란다.

```
> 1:5 \* 2 + 1
[1] 3 5 7 9 11
```

연산에 있어 또 다른 특별한 객체는 행렬이다. 행렬의 연산에 대해서는 ‘2장. 데이터 타입’에서 이미 다뤘다.

#### 벡터 연산

벡터 연산Vectorized Computation(또는 Array Programming)은 벡터 또는 리스트를 한 번에 연산하는 것을 말한다. 벡터 연산이 중요한 이유는 for 문 등을 사용해 값을 하나씩 처리해나가는 대신 벡터나 리스트를 한 번에 처리하는 것이 더 효율적이고 편리하기 때문이다. 가장 간단한 예로 다음과 같이 벡터에 저장된 값을 1씩 증가시키는 경우를 살펴보자.

```
> x <- c(1, 2, 3, 4, 5)
> x + 1
[1] 2 3 4 5 6
```

벡터끼리 연산하는 것도 가능하다. 앞서 ‘2.3.5 진릿값’ 절에서 설명했듯이 벡터 간 연산 시에는 &&가 아니라 &를 사용한다.

```
> x <- c(1, 2, 3, 4, 5)
> x + x
[1] 2 4 6 8 10
> x == x
[1] TRUE TRUE TRUE TRUE TRUE
> x == c(1, 2, 3, 5, 5)
[1] TRUE TRUE TRUE FALSE TRUE
> c(T, T, T) & c(T, F, T)
[1] TRUE FALSE TRUE
```

R의 함수들은 기본적으로 이러한 벡터 기반 연산을 지원한다. 예를 들어, 다음과 같이 sum( ), mean( ), median( ) 등은 벡터를 곧바로 인자로 받을 수 있다.

```
> x <- c(1, 2, 3, 4, 5)
> sum(x)
[1] 15
> mean(x)
[1] 3
> median(x)
[1] 3
```

ifelse( )도 한 번에 적용 가능하다. 다음은 2로 나눈 나머지를 사용해 짝수even, 홀수odd를 판별하는 예다.

```
> x <- c(1, 2, 3, 4, 5)
> ifelse(x %% 2 == 0, "even", "odd")
[1] "odd" "even" "odd" "even" "odd"
```

벡터 연산을 사용하면 데이터 프레임Data Frame에 저장된 데이터 중 원하는 정보를 쉽게 얻을 수 있다. 기본 원리는 데이터 프레임에 진릿값을 지정해 특정 행을 얻어올 수 있다는 점을 이용하는 것이다. 다음은 1행, 3행, 5행에 TRUE를 지정해 해당 행들만 데이터 프레임에서 가져오는 예다.

```
> (d <- data.frame(x=c(1, 2, 3, 4, 5), y=c("a", "b", "c", "d", "e")))
  x y
1 1 a
2 2 b
3 3 c
4 4 d
5 5 e
> d[c(TRUE, FALSE, TRUE, FALSE, TRUE), ]
  x y
1 1 a
3 3 c
5 5 e
```

따라서 행의 선택 기준이 되는 TRUE, FALSE를 벡터 연산으로 만들어주면 특정 행을 선택할 수 있게 된다. 다음은 x 값이 짝수인 행만 선택한 예다.

```
> d[d$x %% 2 == 0, ]
  x y
2 2 b
4 4 d
```

#### NA의 처리

NA는 값이 기록되지 않았거나 관측되지 않은 경우 데이터에 저장되는 값으로 ‘결측치’라고 부른다. 예를 들어, 인구 조사에서 특정 가구가 소득을 묻는 항목에 답을 하지 않았다면 해당 값은 NA로 기록될 것이다.

데이터에 NA가 포함되어 있을 경우 연산 결과가 다음과 같이 NA로 바뀌어버리므로 주의가 필요하다.

```
> NA & TRUE
[1] NA
> NA + 1
[1] NA
```

이러한 문제점을 해결하기 위해 많은 R 함수에서 **na.rm**을 함수 인자로 받는다. na.rm은 NA 값이 있을 때 해당 값을 연산에서 제외할 것인지를 지정하는 데 사용한다. 다음 예를 살펴보자.

```
> sum(c(1, 2, 3, NA))
[1] NA
> sum(c(1, 2, 3, NA), na.rm=TRUE)
[1] 6
```

이처럼 NA 값에 따라 처리를 다르게 하려면 **na.fail, na.omit, na.exclude, na.pass** 함수를 사용한다. 또 다른 예로, 잘 알려진 기계 학습 패키지 중 하나인 caret(Classification and Regression Training)은 NA 처리 방법을 결정한다. 표 3-5에 이 함수들을 보였다.

▼ **표 3-5** NA 처리 함수

| 함수                    | 의미                                                         |
| ----------------------- | ------------------------------------------------------------ |
| na.fail(object, ...)    | object에 NA가 포함되어 있으면 실패한다.                      |
| na.omit(object, ...)    | object에 NA가 포함되어 있으면 이를 제외한다.                 |
| na.exclude(object, ...) | object에 NA가 포함되어 있으면 이를 제외한다는 점에서 na.omit과 동일하다. 그러나 naresid, napredict를 사용하는 함수에서 NA로 제외한 행을 결과에 다시 추가한다는 점이 다르다. |
| na.pass(object, ...)    | object에 NA가 포함되어 있더라도 통과시킨다.                  |

다음 예는 이 함수들의 차이를 보여준다.

```
> (x <- data.frame(a=c(1, 2, 3), b=c("a", NA , "c"), c=c("a", "b", NA)))
  a    b    c
1 1    a    a
2 2 <NA>    b
3 3    c <NA>
> na.fail(x)     # NA가 포함되어 있으므로 실패
Error in na.fail.default(x) : missing values in object
> na.omit(x)     # NA가 포함된 행을 제외
  a b c
1 1 a a
> na.exclude(x)  # NA가 포함된 행을 제외
  a b c
1 1 a a
> na.pass(x)     # NA의 여부에 상관없이 통과
  a    b    c
1 1    a    a
2 2 <NA>    b
3 3    c <NA>
```

따라서 NA를 어떻게 처리할지를 na.action이라는 함수 인자로 받았다면 ‘na.action(데이터 프레임)’을 실행해 현재 처리 중인 데이터를 사용자가 원하는 대로 정제할 수 있다.

*<Note>* na.omit과 na.exclude의 차이

------

다음과 같이 NA가 포함된 데이터 프레임을 가정해보자.

```
  > df <- data.frame(x=1:5, y=seq(2,10,2))
  > df[3, 2]=NA
  > df
  x y
  1 1 2
  2 2 4
  3 3 NA
  4 4 8
  5 5 10
```

이 데이터에 y = ax + b 형태의 선형 모델을 가정해보자. 이 모델은 선형 회귀 함수 lm( )으로 만들 수 있다. 만들어진 모델에 resid( ) 함수를 적용하면 선형 모델로 예측한 값과 실제 y 값 간의 차이인 잔차(residual)를 구할 수 있다(선형 회귀 및 lm, resid 함수 등에 대한 내용은 ‘8장. 선형 회귀’에서 다시 다룬다).

lm( ) 함수는 인자로 na.action을 받으며, 이 값에 따라 NA가 포함된 행을 다루는 방법이 달라진다. 예를 들어, na.omit을 지정하면 다음과 같이 NA가 포함된 3행을 제외하고 모델을 작성한다. 따라서 df에 총 5행이 있지만 resid( )의 결과는 총 4개 값이다.

```
  > resid(lm(y ~ x, data=df, na.action=na.omit))
              1            2            4             5
  -2.982647e-16 3.439354e-16 1.612526e-16 -2.069233e-16
```

반면 na.action에 na.exclude를 지정하면 NA를 제외하고 모델을 만들지만, 잔차(residual)를 구할 때 NA가 포함된 행은 잔차를 NA로 해서 추가한다. 따라서 resid( )의 결과의 길이와 원래 데이터의 길이가 같다.

```
  > resid(lm(y ~ x, data=df, na.action=na.exclude))
              1            2            3             4             5
  -2.982647e-16 3.439354e-16            NA 1.612526e-16 –2.069233e-16
```



### 함수의 정의

#### 기본 정의

함수는 다음과 같은 기본 문법을 사용해 정의한다.

```
function_name <- function(인자, 인자, ...) {
  함수 본문
  return(반환 값)  # 반환 값이 없다면 생략
}
```

예를 들어, 다음은 피보나치 함수를 구현한 예다.

```
> fibo <- function(n) {
+   if (n == 1 || n == 2) {
+     return(1)
+   }
+   return(fibo(n - 1) + fibo(n - 2))
+ }
> fibo(1)
[1] 1
> fibo(5)
[1] 5
```

*<Warning>*

R에서 함수를 정의하는 방법은 이처럼 다른 언어의 함수 정의와 유사하지만 몇 가지 차이점이 있다.

첫째는 값 반환 시 ‘return 반환 값’ 형태가 아니라 함수 호출을 하듯이 **‘return(반환 값)**’ 형태로 작성해야 한다는 점이다.

둘째는 return( )을 생략하면 함수에서 마지막 문장의 반환 값이 함수의 반환 값이 된다는 점이다. 이 점을 이용하면 fibo( ) 함수를 다음과 같이 고쳐 쓸 수 있다.

```javascript
  fibo <- function(n) {
    if (n == 1 || n == 2) {
      1
    } else {
      fibo(n - 1) + fibo(n - 2)
    }
  }
```

그러나 보통은 return( )을 적어주어 코드의 의도를 명확히 한다.

함수를 호출할 때는 인자의 위치를 맞춰서 값을 넘겨주는 방식, 인자의 이름을 지정해서 넘겨주는 방식 두 가지 모두 가능하다. 다음은 이 두 가지 방식을 모두 보여주는 예다.

```javascript
> f <- function(x, y) {
+   print(x)
+   print(y)
+ }
> f(1, 2)      # 인자의 위치에 맞춘 전달
[1] 1
[1] 2
> f(y=1, x=2)  # 인자 이름 지정 방식으로 전달
[1] 2
[1] 1
```

그 외 함수 호출 방법에 대한 다양한 예를 ‘2.2 함수 호출 시 인자 지정’ 절에서 다룬 바 있으니 해당 내용을 참고하기 바란다.



#### 가변 길이 인자

R에서 함수들의 도움말을 살펴보면 ‘…’을 인자 목록에 적은 경우를 종종 볼 수 있다. …은 개수를 알 수 없는 임의의 인자를 표현하는 데 사용하기도 하고, 내부에서 호출하는 다른 함수에 넘겨줄 인자를 표시하는 데도 사용한다.

다음은 가변 인자로 …을 사용한 예다. 함수 f( )에서 …을 인자로 지정한 뒤 이를 하나씩 화면에 출력했다.

```
> f <- function(...) {
+   args <- list(...)
+   for (a in args) {
+     print(a)
+   }
+ }
> f('3', '4')
[1] "3"
[1] "4"
```

다음은 함수 g( )가 인자 z와 …을 인자로 받아서 인자 z는 자신이 처리하고 나머지 인자들은 함수 f로 넘겨 처리하는 예다. 코드에서 f( )를 호출할 때 마치 명시적인 인자를 넘겨주듯이 …을 인자로 지정했다.

```
> f <- function(x, y) {
+   print(x)
+   print(y)
+ }
> g <- function(z, ...) {
+   print(z)
+   f(...)
> g(1, 2, 3)
[1] 1
[1] 2
[1] 3
```

수업시간 예제 

```javascript
f3 <- function(...){
sum <- 0
  for(i in (...)){
   if(i%%2 ==0){
      print(i)
     sum = sum +i
    }
  }
  return(sum)
}

f3(c(1:100))
```

### 스코프

코드에 기술한 이름(예를 들면, 변수명)이 어디에서 사용 가능한지를 정하는 규칙을 스코프Scope라고 한다. R에서는 대부분의 현대적인 프로그래밍 언어가 그러하듯이 문법적 스코프lexical scope(정적 스코프static scope)를 사용하며, 문법적 스코프는 변수가 정의된 블록 내부에서만 변수를 접근할 수 있는 규칙을 말한다.

R의 스코프 규칙을 코드를 통해 알아보자. 예를 들어, 콘솔에서 변수를 선언하면 모든 곳에서 사용 가능한 전역 변수가 된다. 이 변수는 현재 실행 중인 R 세션 동안 유효하다. 따라서 코드를 여러 파일에 나눠놓고 source( )를 사용해 실행할 경우 다른 파일에서도 해당 변수를 사용할 수 있다.[**2**](https://thebook.io/006723/ch03/05/#footnote-96400-2)

다음은 콘솔에서 변수 n을 선언한 다음, 이 변수를 함수 내부에서 사용한 예다.

```
> n <- 1
> f <- function() {
+    print(n)
+ }
> f()
[1] 1
> n <- 2
> f()
[1] 2
```

만약 함수 내부에서 전역 변수와 같은 이름의 지역 변수를 사용하면, 함수 내부의 지역 변수가 우선한다.

```
> n <- 100
> f <- function() {
+    n <- 1
+    print(n)
+ }
> f()
[1] 1
```

만약 함수 내부에서도, 전역 변수로도 선언되지 않은 이름을 사용하면 에러다. 이를 살펴보기에 앞서 R 객체를 메모리에서 삭제하거나 객체를 나열하는 함수들에 대해 살펴보자.

▼ **표 3-6** 메모리상의 객체 관련 함수

| rm : 지정한 환경[**3**](https://thebook.io/006723/ch03/05/#footnote-96400-3)에서 객체를 삭제한다. |
| ------------------------------------------------------------ |
| `rm(   ...,                       # 삭제할 객체의 목록   list=character(),          # 삭제할 객체를 나열한 벡터   envir=as.environment(pos)  # 객체를 삭제할 환경 )` |
| ls : 객체를 나열한다.                                        |
| `ls(   name, # 객체를 나열할 환경의 이름   envir # name 대신 직접 환경을 지정할 경우 사용 )`반환 값은 객체 이름의 문자열 벡터다. |

따라서 rm(list=ls( ))는 메모리에 있는 모든 객체를 삭제하는 명령이 된다. 다음은 rm(list=ls( ))를 사용해 메모리에 존재하는 객체들을 삭제하여 앞서 예제에서 선언한 n을 없앤 다음, 함수 f( )에서 n을 출력해본 예다.

```
> rm(list = ls())
> f <- function() {
+ print(n)
+ }
> f()
Error in print(x) : object 'n' not found
```

------

**2** ‘1.6 배치 실행’ 절에서 source( )에 대해 설명했다.

**3** 환경(environment)은 명명된 객체(named object)를 나열한 프레임(frame), 해당 환경을 감싸고 있는 또 다른 환경(enclosing environment)으로 구성된다. 환경을 사용하면 호출된 함수(callee)가 호출한 쪽(caller)의 변수를 조작하는 등의 작업을 할 수 있다



변수는 내부 블록에서만 접근할 수 있으므로 함수 내부에 정의한 이름은 함수 바깥에서 접근할 수 없다.

```
> rm(list = ls())
> f <- function() {
+ n <- 1
+ }
> f()
> n
Error : object 'n' not found
```

함수 내에서 이름은 함수 안의 변수들로부터 먼저 찾는다. 같은 이유로 함수 인자의 변수명 역시 전역 변수보다 우선한다.

```
> n <- 100
> f <- function(n) {
+ print(n)
+ }
> f(1)
[1] 1
```

중첩 함수에도 같은 규칙이 적용된다. 다음 코드에서 함수 g( ) 안에는 변수 a가 선언되어 있지 않다. 따라서 R 언어는 g( ) 함수를 감싼 함수 f( )로부터 변수 a를 찾는다.

```
> f <- function(x) {
+   a <- 2
+   g <- function(y) {
+     print(y + a)
+   }
+   g(x)
+ }
> f(1)
[1] 3
```

그러나 만약 함수 f( )마저도 변수 a를 포함하고 있지 않다면 전역 변수 a를 사용하게 된다.

```
> a <- 100
> f <- function(x) {
+   g <- function(y) {
+   print(y + a)
+   }
+   g(x)
+ }
> f(1)
[1] 101
```

내부 블록에서 외부 블록에 선언된 값을 수정하고자 할 때는 주의가 필요하다. 내부 블록이 외부 블록보다 우선하므로 <-를 사용한 값의 할당 시, 값이 할당되는 대상이 내부 블록으로 간주되기 때문이다. 예를 들어, 함수 f( ) 안에 변수 a가 있고 중첩된 함수 g( )에서 함수 f( ) 안의 변수 a에 값을 할당하려고 하는 다음 코드를 살펴보자.

```
> f <- function() {
+   a <- 1
+   g <- function() {
+     a <- 2
+     print(a)
+   }
+   g()
+   print(a)
+ }
> f()
[1] 2
[1] 1
```

이 코드에서는 함수 g( )에서 함수 f( )에 선언된 변수 a에 2를 할당하려 했지만 <-는 함수 g( ) 내부에 새로운 변수 a를 만들고 해당 변수에 2를 할당한다. 따라서 f( )에서 print(a)가 수행될 때 출력은 2가 아니라 1이 된다. 만약 함수 g에서 함수 f( ) 안의 변수 또는 전역 변수에 값을 할당하려면 <<-를 사용해야 한다.

```
> b <- 0
> f <- function() {
+   a <- 1
+   g <- function() {
+     a <<- 2
+     b <<- 2
+     print(a)
+     print(b)
+   }
+   g()
+   print(a)
+   print(b)
+ }
> f()
[1] 2
[1] 2
[1] 2
[1] 2
```

실행 결과 g( ) 안에서 <<-를 사용한 값의 할당은 함수 f( )에 선언된 a와 전역 변수인 b를 대상으로 이루어졌음을 볼 수 있다.





### 값에 의한 전달

R에서는 모든 것이 객체다. 또, 객체는 함수 호출 시 일반적으로 값으로 전달된다. 이를 변수에 대한 참조Reference에 의한 방식에 대비해 값에 의한 전달Pass By Value이라고 한다. 값으로 전달된다는 말은 객체가 복사되어 함수로 전달된다는 의미다.

여기에는 예외(환경Environment, 심볼Symbol, 스페셜Special, 빌트인Builtin 등)도 있다. 그러나 이들에 대한 내용은 이 책의 범위를 벗어나므로 관심 있는 독자는 참고자료 [[2\]](https://thebook.io/006723/ch03/09/#ref2)를 확인하기 바란다. 이 책에서 다루는 범위 안에서는 객체가 값으로 넘어간다고 간주해도 좋다.

값으로 데이터가 넘어가는 예를 살펴보자. 예를 들어, 다음과 같이 데이터 프레임을 함수에 인자로 주었을 때 함수 내부에서 수행한 변경은 원래 객체에 반영되지 않는다. 왜냐하면 함수 f( ) 안에서 df2란 f( )를 호출한 쪽에서 넘긴 객체를 가리키는 참조가 아니라 넘겨받은 df를 복사한 새로운 데이터 프레임이기 때문이다.

```
> f <- function(df2) {
+ df2$a <- c(1, 2, 3)
+ }
> df <- data.frame(a=c(4, 5, 6))
> f(df)
> df
a
1 4
2 5
3 6
```

만약 인자로 받은 df를 수정하고 이를 함수를 호출한 쪽에 반영하려면 함수 f에서 수정된 값을 반환하고 함수를 호출한 쪽에서 원래 변수에 할당해야 한다.

```
> f <- function(df) {
+ df$a <- c(1, 2, 3)
+ return(df)
+ }
> df <- data.frame(a=c(4, 5, 6))
> df <- f(df)  # df의 값을 덮어쓴다.
> df
a
1 1
2 2
3 3
```

결과적으로 특별한 객체(예를 들면, 네트워크 접속connection이나 파일 입출력 등)를 제외하고는 객체의 상태가 함수에 의해 직접 수정되지 않는다. 이런 이유로 어떤 함수를 호출하더라도 인자로 넘긴 객체가 수정되지 않음을 보장받는다. 이 주제에 더 관심 있는 독자는 <Mutable objects in R>[[3\]](https://thebook.io/006723/ch03/09/#ref3)을 참고하기 바란다.

*<Note>* 쓰기 시 복사(Copy on Write 또는 Copy on Modify)

------

여기까지 읽은 독자는 ‘그렇다면 객체가 함수에 넘겨질 때마다 새로운 객체를 만들어야 하니 메모리 사용량이 너무 많아지지 않을까?’ 또는 ‘매번 새로운 객체를 만들려면 속도가 느려지지 않을까?’ 의심을 품게 될 것이다. 실제로 매번 복사가 일어나야 한다면 이러한 부담이 있는 것이 사실이다.

그러나 R을 포함한 현대적 언어는 함수 호출 시 곧바로 객체를 복사하기보다는 객체의 값을 바꿀 필요가 있을 때만 복사를 수행하는 ‘쓰기 시 복사(Copy On Write)’ 기법을 사용한다. 쓰기 시 복사에서는 데이터 프레임 등의 객체를 어떤 함수에 넘겼을 때 해당 함수가 객체 내부 값을 바꾸는 시점에 이르러서야 값이 수정된 새로운 복사본을 만든다. 따라서 읽기 작업만 수행할 때는 복사에 따른 오버헤드를 염려하지 않아도 된다.



### 객체의 불변성

R의 객체는 (거의 대부분의 경우에) 불변immutable이다.[4] 객체 지향 프로그래밍OOP, Object Oriented Programming에 친숙하지 않은 독자라면, 객체라는 용어는 R에서 메모리에 할당된 데이터 구조들을 뜻한다고 생각하면 된다. 예를 들어, 벡터를 하나 메모리에 만들었으면 그것이 객체고, 리스트를 하나 만들었어도 객체다.

프로그래밍에서 값이 불변이란 말은 수정하는 것이 불가능하다는 뜻이다. 따라서 a라는 리스트 객체를 수정하는 것처럼 보이는 다음 코드는 실제로는 a 객체를 변경하는 것이 아니다.

```
> a <- list()
> a$b <- c(1, 2, 3)
```

코드를 보면 리스트 a에 새로 필드 b를 만들고 거기에 c(1, 2, 3)을 할당하는 수정처럼 보인다. 그러나 실제로 일어나는 일은 a를 복사한 새로운 객체 a′을 만들고, 이 a′에 필드 b를 추가하고 해당 필드에 c(1, 2, 3)을 채워넣은 다음, 변수명 a가 a′을 가리키도록 하는 것이다.

그림 3-1을 살펴보자. 최초의 변수 a는 어떤 객체에 붙여진 이름이었다. 그러나 그 객체의 값을 바꾸면 이전 객체는 버려지며 새로이 a′=c(1, 2, 3)을 담고 있는 새로운 객체가 만들어지고, a는 이 새로운 객체의 이름이 된다.

▼ **그림 3-1** 객체의 불변성![그림 3-1 객체의 불변성](https://thebook.io/img/006723/115.jpg)

이를 직접 코드로 확인해보자. 메모리를 추적하기 위해 먼저 다음 두 가지 함수를 알아둘 필요가 있다.

▼ **표 3-7** 객체의 복사 추적 관련 함수

| tracemem : 객체의 복사를 추적한다.          |
| ------------------------------------------- |
| `tracemem(   x  # 추적할 R 객체 )`          |
| untracemem : 객체 복사 추적을 중단한다.     |
| `untracemem(   x  # 추적을 중단할 R 객체 )` |

다음은 tracemem( )을 사용하여 리스트 a를 추적하게 한 다음, 리스트 a의 값을 수정하자 a가 복사됨을 보여준다.

```
> a <- list()
> tracemem(a)
[1] "<0x081cd534>"
> a$b <- c(1, 2, 3)  # 메모리 복사가 발생해 0x07e73df4 주소에 객체가 새로 만들어짐
tracemem[0x081cd534 -> 0x07e73df4]:
> untracemem(a)
```

‘2.4 벡터’ 절에서 벡터 연산을 설명하면서 벡터 기반 연산을 사용하는 것이 for 등의 반복문을 사용하는 것보다 효율적이라고 한 바 있다. 그 이유 중 하나가 바로 객체가 불변이라는 점이다. 예를 들어, for 문 안에서 벡터의 인자를 하나씩 바꾸는 다음 코드는 v[i] 값을 1씩 증가시킬 때마다 i번째 값이 수정된 벡터를 매번 새로 만들어 v에 할당한다. 따라서 새로운 객체 1,000개를 생성하는 비효율이 발생한다.

```
> v <- 1:1000
> for (i in 1:1000) {
+ v[i] <- v[i] + 1  # i 번째 값을 바꿀 때마다 새로운 벡터가 생성된다!
+ }
```

반면 같은 일을 하는 다음 코드는 v 안에 있는 전체 값을 1만큼 증가시킨 객체를 한 개 만든 다음, 이를 v에 할당한다.

```
> v <- 1:1000
> v <- v + 1
```

이처럼 벡터 연산이 더 빠른 이유는 이러한 메모리 사용 최적화 문제와도 관련이 있다. 메모리 문제를 확인하는 한 가지 방법은 다음 코드를 실행해보는 것이다.

```
> rm(list = ls())  # 메모리에 있는 객체들을 삭제
> gc()             # 가비지 컬렉션(Garbage Collection)4을 수행해 사용하지 않는 메모리를 해제
> v <- 1:99999999
> for (i in 1:99999999) {
+   for (j in 1:99999999) {
+     v[j] <- v[j] + 1
+   }
+ }
```

위 코드를 실행하고 for 문이 수행되는 동안 작업 관리자를 살펴보면 메모리 사용량이 서서히 증가함을 알 수 있다.

------

**4** 가비지 컬렉션(쓰레기 수집으로도 번역됨)은 사용이 종료된 객체가 사용하고 있던 메모리를 자동으로 해제하는 기법이다.

### 큐

큐Queue는 먼저 들어온 데이터를 먼저 처리FIFO, First In First Out하는 데 사용하는 자료 구조다. 큐는 사람들이 차례로 줄을 서 있고, 줄의 제일 앞에 서 있는 사람부터 자기 일을 처리하는 모습을 연상하면 된다. 새로 도착한 사람은 줄의 맨 뒤에 서서 기다린다.

큐는 다음 세 가지 함수로 구현한다.

**•** Enqueue : 줄의 맨 뒤에 데이터를 추가한다.

**•** Dequeue : 줄의 맨 앞에 있는 데이터를 가져온다. 가져온 데이터는 줄에서 빠진다.

**•** Size : 줄의 길이, 즉 자료 구조 내에 저장된 데이터의 수를 반환한다.

이 세 가지 함수를 지원하는 큐를 작성해보자.

```
> q <- c()
> q_size <- 0
> enqueue <- function(data) {
+ q <<- c(q, data)
+ q_size <<- q_size + 1
+ }
> dequeue <- function() {
+ first <- q[1]
+ q <<- q[-1]
+ q_size <<- q_size - 1
+ return(first)
+ }
> size <- function() {
+ return(q_size)
+ }
```

위 코드에서 큐에 저장될 데이터는 벡터 q를 사용해 저장하고 있다. q_size는 큐에 저장된 데이터 수를 기록하는 목적으로 사용한다.

함수 enqueue( )는 q에 이미 저장되어 있는 데이터에 인자로 받은 데이터를 추가하여 다시 변수 q에 할당한다. 이때 <<-를 사용해 전역 변수에 있는 q를 직접 접근하게 했다. 마지막으로 q_size의 값을 1 증가시킨다.

함수 dequeue( )는 q에 저장된 데이터 중 첫 번째 요소를 first에 저장하고, q에는 이 데이터를 제외한 데이터를 저장한 다음 first를 반환한다. 이때 q_size가 1 감소한다.

함수 size( )는 q의 길이인 q_size를 반환한다.

위 코드는 다음과 같이 사용할 수 있다.

```
> enqueue(1)        # 1이 줄의 끝에 선다.
> enqueue(3)        # 3이 줄의 끝에 선다.
> enqueue(5)        # 5가 줄의 끝에 선다.
> print(size())     # 줄의 길이는 3이다.
[1] 3
> print(dequeue())  # 첫 번째로 대기 중인 데이터인 1을 가져온다.
[1] 1
> print(dequeue())  # 두 번째로 대기 중인 데이터인 3을 가져온다.
[1] 3
> print(dequeue())  # 세 번째로 대기 중인 데이터인 5를 가져온다.
[1] 5
> print(size())     # 데이터가 없어 크기가 0이다.
[1] 0
```