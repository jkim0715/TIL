# R 데이터 분석

## 왜 R 인가?

R은 데이터 분석을 위한 통계 및 그래픽스를 지원하는 자유 소프트웨어 환경, 오픈소스.

1. 통계 분석 언어인 S에 기반을 두고 있음.

2. Data Mining, 같은 필드가 인기가 높을 때 인기가 많아지기 시작.

3. R은 컴퓨터 언어이자 다양한 패키지의 집합.

    다양한 라이브러리가 하루에도 수백개씩 생기곤 함.

4. 데이터 분석을 해낼 수 있음 ( 통계, 기계학습, 금융, 생물정보학, 그래픽스 등)

5. 통계를 기반으로 한 데이터 분석 

6. CRAN(http://cran.r-project.org/web/views/) 에서 다양 한 패키지들을 다운로드 받을 수 있음

7. R은 자바연동, 빅데이터 연동이 쉽다. (RHIVE를 이용하여 하이브 환경에서 R사용)

8. 원래 파이썬이 통계 기능쪽에서 R보다 딸렸는데 요즘은 여러가지 통계 라이브러리가 추가되었음

9. R를 쓰는 이유는 통계 패키지를 활용할 수 있기 때문이다.

I. R설치하기

- http://www.r-project.org/
- Windows 용 다운로드 
- default값으로 설치



II. Rstudio

- IDE 툴 (Integrated  Development Environment)

- 이클립스 같은게 IDE 툴 임.
- rstudio.com 에서 다운로드
- free version download - Rstudio 1.2.1335 -Windows 7+(64bit)
- R이랑 연동해서 돌아감 



III. 활용

file - new project - new Directory - new project - (폴더 이름이랑 경로 설정하고 create)r

왼쪽 상단 + 눌러서 R Script 누르면 코드 입력 창 같은게 나오는데 이게 자바 같은거

1. run은 라인별 실행
2. source는 전체 실행 
3. console창은 리눅스 터미널과 명렁어 가 비슷하다

패키지 활용하기

패키지 다운로드

install.packages("randomForest")

패키지 저장 경로 :  C:\Program Files\R\R-3.6.1\library 밑에 저장됨



패키지 사용하기 

```R
library(randomForest)
```

마치 자바에서 외부라이브러리를 Import 해서 사용하는 것 과 같이 RScript 맨 윗부분에 작성





## 데이터 타입

I. 변수

변수이름 규칙

- 변수명 : 알파벳, 숫자, _(언더스코어),.(마침표)로 구성.  -(하이폰)은 사용 할 수 없다.
- . 으로 시작한다면 뒤에 숫자가 올 수 없다.

변수 값 할당

 = 대신 <- (화살표)를 씀

=은 명령 최상위 수준에서만 사용



함수 호출 시 인자 지정

R의 함수인자는 위치 또는 이름으로 지정 가능.

```
foo(a, b, c=1, d=2)

foo(1, 2, 3, 4)
foo(3, 4)
```

함수선언시 값을 넣어주면 default 값으로 들어가서 따로 c와 d를 인자로 전달하지않으면 각각 1 , 2로 지정되어 호출함.



--본격적인 R에서의 변수 타입--

R에서 데이터 타입의 기본은 벡터(Vector)



###  스칼라 Scalar

- 숫자

- NA (Not Available)

  연산시 배제해야 함이 맞음.

   is.na 를 활용하여 ( NA가 저장되어 있으면 TRUE 아니면 FALSE를 리턴함)

- NULL

  변수가 초기화 되지 않았을 때 사용 NA와 구분하여 사용.

  대문자 NULL로 써야 함.

- 문자열

- 진리값

  

팩터 (Factor) 

- 범주형 데이터 자료를 표현하기 위한 데이터 타입.

- ```
  sex <- factor("m",c("m","f"))
  
  sex
  [1] m
  
  Levels: m f
  ```

  



### 벡터

다른언어에서 배열 개념

Example)

```javascript
#배열 선언  score
score <- c(100,90,80);  

#배열 컬럼지정
names(score) <-c("lee","kim","han");

#score 출력
print(score);

#배열의 첫번째 출력 (컬럼이랑 같이 출력 됨)
print(score[1]);

#배열 안 합산값 출력
print(sum(score));

#컬럼 "lee"의 값 출력
print(score["lee"]);

#1~10까지 배열 v1으로 선언
v1 <- c(1:10);

#배열 첫번째 값 출력
print(v1[1]);

#배열 v1에서 열번째 값 뺴고 출력
print(v1[-10])

#배열 인자값 카운트
print(NROW(v1))
print(length(v1))

#5~8번쨰 인자값 출력
print(v1[5:8]);

```



두개 이상일 떄는 무조건 **c (vector)**를 이용해야 한다.



벡터 연산





### 리스트 

R에서의 리스트는 Key Value를 의미함



### 행렬 (Matrix)

대부분의 데이터는 정방행렬 형태일 것.

행렬의 연산

한가지 타입의 데이터만 들어감

```javascript
ma <- matrix(c(1:6), nrow=3)
print(nrow(ma))
print(ncol(ma))
```







### 배열(Array)

다차원 데이터 

안함.



### **데이터 프레임 (Data Frame)**

- 다양한 타입의 데이터가 들어간다.

처리할 데이터를 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 데이터 프레임의 각 열에는 관측값의 이름이 저장되고, 각 행에는 매 관측 단위마다 실제 얻어진 값이 저장된다.

| 성명   | 국어 | 영어 |
| ------ | ---- | ---- |
| 홍길동 | 80   | 94   |
| 김길동 | 97   | 100  |
| 박길동 | 85   | 97   |

 데이터 프레임은 R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.



#### 데이터 프레임 생성

- data.frame : 데이터 프레임을 생성한다.

```javascript
df1 <- data.frame(x=c(1:5),y=c(5:9),z=c(10:14))
print(df1)
print(df1$x)
print(df1[1,])
print(df1[,2])
print(df1$x[3])
print(df1[3,1])
print(df1["x"])

print(df1)
df2 = df1[c(2:5),c(2:3)]
print(df2)
```

- str : 임의의 R 객체의 내부 구조(structure)를 보인다.

```javascript
df1 <- data.frame(
  "lee" = c(90,99,89,87),
  "kim" = c(91,98,81,86),
  "han" = c(92,97,82,85),
  "jun" = c(93,96,83,84),
  "goo" = c(94,95,84,83),
  "grade" = c("A","B","C","D")
)

print(df1)
# avg per student
each1 <- c(mean(df1$lee),
           mean(df1$kim),
           mean(df1$han),
           mean(df1$jun),mean(df1$goo))
print(each1)
print(mean(each1))

# avg per subject

each2 <- c(sum(df1[1,]),
          sum(df1[2,]),
           sum(df1[3,]),
           sum(df1[4,]))
print(each2)  

str(df1)

#change original value to new value
df1$lee <- c(0,0,0,0)
#able to append new col
df1$hong <- c(100,100,100,100)
```

```javascript
df1 <- data.frame(
  a=c(1:4),
  b=c(5:8),
  c=c(9:12),
  d=c("A","B","A","B")
)
rownames(df1) <- c("aa","bb","cc","dd")
print(df1)

df2 <- df1[,-4]
print(df2)

print(df2[1,3])
print(df2$a)
print(mean(df2$a))
#need to convert data.frame to numeric in order to get the mean
print(mean(as.numeric(df2[1,])))

df3 <- df1[c(1:4),c(1:3)]
print(class(df3[1:2]))

df4 <- df1[,c("c","b")]
print(df4)

View(df3)


```



Aggregate

```javascript
st <- read.csv("student.csv",
               header= TRUE,
               stringsAsFactors = FALSE,
               na.strings = "NA",
               encoding = "EUC-KR"
)

#Select Students whose KO grade > 91
st[st$KO >= 91 ,]


#Select Students whose KO grade > 91 and also SI grade > 80
#Make sure need to repeat name of Variables to give some conditions 
st[st$KO >= 91 & st$SI > 80,]

st$AVG <- st[,mean(c(3:6))]
st$CLASS <- c(1,1,1,2,2,2,3,3)

#sth like group by
aggregate(data=st[st$KO>=90,], AVG~CLASS,mean)
```







### 타입판별

데이터를 처리하기 위해 여러 함수를 호출하다 보면 반환된 결과의 타입이 무엇인지 분명하지 않을 때가 많다. 이 경우 다음 함수들을 사용하여 데이터 타입을 손쉽게 판단할 수 있다.

▼ **표 2-23** 데이터 타입 판별 함수

| 함수             | 의미                                     |
| ---------------- | ---------------------------------------- |
| class(x)         | 객체 x의 클래스                          |
| str(x)           | 객체 x의 내부 구조                       |
| is.factor(x)     | 주어진 객체 x가 팩터인가                 |
| is.numeric(x)    | 주어진 객체 x가 숫자를 저장한 벡터인가   |
| is.character(x)  | 주어진 객체 x가 문자열을 저장한 벡터인가 |
| is.matrix(x)     | 주어진 객체 x가 행렬인가                 |
| is.array(x)      | 주어진 객체 x가 배열인가                 |
| is.data.frame(x) | 주어진 객체 x가 데이터 프레임인가        |

다음은 벡터, 행렬, 데이터 프레임에 class( )를 적용하여 클래스를 구하는 예를 보여준다.

```
> class(c(1, 2))
[1] "numeric"
> class(matrix(c(1, 2)))
[1] "matrix"
> class(data.frame(x=c(1, 2), y=c(3, 4)))
[1] "data.frame"
```

class( )는 문자열로 데이터 타입을 반환하는데, 이 예에서는 숫자형 벡터에 numeric, 행렬에 matrix, 데이터 프레임에 data.frame을 반환했다. 특히 class( )에 벡터를 인자로 전달한 경우 numeric이 반환되었는데, 이는 벡터에 저장된 값이 숫자기 때문이다. 벡터에 저장된 데이터 타입에 따라 이 값은 logical, character, factor 등이 될 수 있다.

데이터 타입은 str( )로도 확인해볼 수 있다. 다음 예에서 벡터와 행렬의 결과가 유사해 보이지만 벡터의 경우 차원이 [1:2](1차원에 값이 2개)라고 표시되어 있는 반면, 행렬은 차원이 [1:2, 1](2차원이고 2행 1열)로 표시되어 있는 점이 다르다.

```
> str(c(1, 2))
num [1:2] 1 2
> str(matrix(c(1,2)))
num [1:2, 1] 1 2
> str(list(c(1,2)))
List of 1
$ : num [1:2] 1 2
> str(data.frame(x=c(1,2)))
'data.frame': 2 obs. of 1 variable:
$ x: num 1 2
```

R의 데이터 타입에는 타입 이름이 ‘typename’이라 할 때 ‘is.typename( )’ 형태의 함수가 존재한다. 이 함수들은 주어진 객체 x가 ‘typename’ 데이터 타입에 해당하는지를 판별하는 용도로 사용한다. 이러한 함수의 예로 팩터인지 여부를 알려주는 is.factor( ), 숫자를 저장한 벡터인지를 알려주는 is.numeric( ), 문자열을 저장한 벡터인지를 알려주는 is.character( ) 등을 들 수 있다. 다음에 몇 가지 함수의 사용 예를 보였다.

```
> is.factor(factor(c("m", "f")))
[1] TRUE
> is.numeric(1:5)
[1] TRUE
> is.character(c("a", "b"))
[1] TRUE
> is.data.frame(data.frame(x=1:5))
[1] TRUE
```

‘is.typename( )’ 형태의 함수 목록은 표 2-23을 참조하기 바란다.

### 타입변환

R의 형 변환은 암시적으로 발생할 수 있고, 때에 따라 형 변환이 전혀 예상치 않은 곳에서 일어난다. 예를 들어, 데이터 프레임 d에 2개 컬럼이 있고 각 컬럼의 데이터 타입이 numeric(숫자를 저장한 벡터)이라고 가정하자. 이때 d[, 1]은 첫 번째 컬럼의 데이터를 데이터 프레임이 아닌 numeric(즉, 벡터)으로 반환한다. d에 대한 연산의 결과가 데이터 프레임이 아니라 numeric이라는 점은 사용자를 당황하게 할 수 있는 점이며, 이러한 변환을 피하고 싶다면 drop=FALSE를 지정해야 한다. 또는 파일에서 문자열을 불러들였을 때 data.frame( )으로 데이터 프레임을 생성하면서 stringsAsFactor=FALSE를 지정하지 않으면 문자열이 character(문자열 벡터)가 아니라 팩터가 된다.

이와 같은 암시적 형 변환에 대비하기 위해 모든 의심스러운 함수 호출 뒤에는 ‘2.9 타입 판별’ 절에서 설명한 str( ), class( )를 사용해 현재 사용하는 데이터가 올바른 데이터 타입인지 계속 확인할 필요가 있다.

반면 타입을 강제로 변환하고자 할 때도 있을 것이다. 문자열 벡터를 팩터로 변환하는 경우 등이 그 예다. 이러한 변환을 하는 한 가지 방법은 타입 이름이 ‘typename’이라 할 때 ‘as.typename( )’이라는 함수를 사용하는 것이다. 다음에 관련 함수의 목록을 보였다.

▼ **표 2-24** 데이터 타입 변환 함수

| 함수             | 의미                                        |
| ---------------- | ------------------------------------------- |
| as.factor(x)     | 주어진 객체 x를 팩터로 변환                 |
| as.numeric(x)    | 주어진 객체 x를 숫자를 저장한 벡터로 변환   |
| as.character(x)  | 주어진 객체 x를 문자열을 저장한 벡터로 변환 |
| as.matrix(x)     | 주어진 객체 x를 행렬로 변환                 |
| as.array(x)      | 주어진 객체 x를 배열로 변환                 |
| as.data.frame(x) | 주어진 객체 x를 데이터 프레임으로 변환      |

또 다른 타입 변환 방법은 factor( ), data.frame( ) 등과 같이 데이터를 생성하는 함수에 다른 타입의 데이터를 인자로 넘겨주는 것이다. 이 경우 필요에 따라 형 변환이 수행된다.

as.typename( )’ 유형부터 살펴보자. 다음은 “a”, “b”, “c”가 저장된 문자열 벡터를 팩터로 변환했다가 다시 벡터로 변환하는 예다.

```
> x <- c("a", "b", "c")
> as.factor(x)
[1] a b c
Levels: a b c
> as.character(as.factor(x))
[1] "a" "b" "c"
```

다음은 행렬을 데이터 프레임으로 변환하는 예다.

```
> x <- matrix(1:9, ncol=3)
> as.data.frame(x)
  V1  V2  V3
1  1   4   7
2  2   5   8
3  3   6   9
```

또는 factor( ), matrix( ), data.frame( ) 등과 같은 데이터 생성 함수에 곧바로 다른 타입을 넘겨 형 변환을 할 수도 있다. 다음은 행렬을 데이터 프레임으로 변환하기 위해 matrix( )의 결과를 data.frame( )에 곧바로 넘긴 예다.

```
> (x <- data.frame(matrix(c(1, 2, 3, 4), ncol=2)))
  X1 X2
1  1  3
2  2  4
```

다음은 리스트를 data.frame( )에 넘겨 데이터 프레임으로 변환한 예다.

```
> data.frame(list(x=c(1, 2), y=c(3, 4)))
  x y
1 1 3
2 2 4
```

두 가지 방법이 모두 가능하다면 그 차이가 무엇일까? ‘as.typename( )’은 표현이 명확하고 간략하지만 경우에 따라 지원하는 변환의 정도가 약하다. 예를 들어, c(“m”, “f”)의 벡터를 as.factor( )로 변환하는 경우를 생각해보자. 이 경우 f가 알파벳 순서상 m보다 앞서므로 as.factor(c(“m”, “f”))의 결과에서 팩터의 레벨은 “f m”으로 정해진다. 팩터의 레벨을 “m f”로 하려면 어떻게 해야 할까? as.factor( )는 변환할 데이터 이상의 인자를 받지 않으므로 as.factor( )를 사용할 때 팩터의 레벨을 “m f”로 지정할 수 있는 방법이 없다. 팩터 레벨의 순서를 “m f”로 하고 싶다면 다음과 같이 factor( ) 함수를 써야 한다.

```
> as.factor(c("m", "f"))
[1] m f
Levels: f m
> factor(c("m", "f"), levels=c("m", "f"))
[1] m f
Levels: m f
```

따라서 상황에 따라 두 가지 방법을 모두 사용해보고 help(함수명)으로 볼 수 있는 도움말을 참고해 적절한 방식을 찾아 형 변환을 수행해야 한다.



## R 프로그래밍

### R의 특징

R 프로그래밍은 다른 언어와 상당히 유사해 예시 코드를 참조하면 쉽게 프로그래밍 방법을 배울 수 있다. 그러나 R에는 다른 언어와 몇 가지 특징적인 차이점이 있어 이들을 잘 이해할 필요가 있다.

첫째는 데이터를 다루는 방법이다. 다른 프로그래밍 언어에서는 흔히 for 문을 사용해 데이터를 한 행씩 읽어들여 처리한다. 하지만 R에서는 전체 데이터를 한 번에 다루는 벡터 연산을 더 자주 사용한다.

둘째는 결측치NA다. R에는 초기화되지 않은 변수에 저장하는 NULL 외에도 관측 또는 기록되지 않은 데이터를 표시하기 위한 NA가 있다. 따라서 코드에서 NA를 제대로 구분해서 처리하지 않으면 원하는 결과를 얻지 못할 수도 있다. 

셋째는 객체의 불변성이다. 대부분의 R 객체는 그 값을 수정할 수 없다. 따라서 문법적으로 객체의 데이터를 수정하고 있다고 보이는 코드에서도 실제로는 해당 부분의 값이 수정된 새로운 객체가 생성된다.



### 흐름 제어(조건문과 반복문)

이 절에서는 프로그래밍의 필수 요소가 되는 조건문과 반복문(if, for, while, repeat)에 대해서 알아본다. 문법은 대부분의 언어와 유사하므로 어렵지 않게 익힐 수 있을 것이다. switch 문도 존재하지만 잘 사용하지 않으며, 대신 조건문을 많이 사용한다.



#### if

먼저 조건에 따라 코드의 수행 여부를 결정하는 if 문에 대해 살펴본다. 다음은 if 문의 문법 구조를 정리한 표다.

▼ **표 3-1** if 문법

| 문법                                                         | 의미                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `if (cond) {    cond가 참일 때 실행할 문장 } else {    cond가 거짓일 때 실행할 문장 }` | 조건 cond가 참, 거짓인 경우에 따라 {} 블록을 실행한다. 필요한 경우 else 블록을 지정할 수 있다. |

다수의 TRUE, FALSE 데이터를 한 번에 처리한다면 ifelse( ) 함수를 고려할 수 있다.

▼ **표 3-2** ifelse( ) 함수

| ifelse : 주어진 test 값에 따라 yes 또는 no 값을 반환한다.    |
| ------------------------------------------------------------ |
| `ifelse(  test, # 참, 거짓을 저장한 객체  yes, # test가 참일 때 선택할 값  no # test가 거짓일 때 선택할 값 )`test에 다수의 TRUE, FALSE가 저장되어 있을 때 TRUE에 대해서는 yes 값을, FALSE에 대해서는 no 값을 선택하여 반환한다. |

조건문 if의 예를 살펴보자.

```javascript
> if ( TRUE ) {
+    print("TRUE")
+    print("hello")
+ } else {
+    print("FALSE")
+    print("world")
+ }
[1] "TRUE"
[1] "hello"
```

위 코드의 결과는 “TRUE”, “hello”다.

ifelse( )를 사용하면 if 문을 다수의 데이터에 한 번에 적용하는 연산이 가능하다. 다음은 1, 2, 3, 4, 5에서 값이 짝수일 경우 “even”, 홀수일 경우 “odd”를 출력하는 예다.

```javascript
> x <- c(1, 2, 3, 4, 5)
> ifelse(x %% 2 == 0, "even", "odd")
[1] "odd" "even" "odd" "even" "odd"
```



#### 반복문

R의 반복문에는 for, while, repeat 문이 있다. 다음은 이 세 가지 문법을 설명한 표다.

▼ **표 3-3** 반복문의 문법

| 문법                                            | 의미                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `for (i in data) {   i를 사용한 문장 }`         | data에 들어 있는 각각의 값을 변수 i에 할당하면서 각각에 대해 블록 안의 문장을 수행한다. |
| `while (cond) {   조건이 참일 때 수행할 문장 }` | 조건 cond가 참일 때 블록 안의 문장을 수행한다.               |
| `repeat {   반복해서 수행할 문장 }`             | 블록 안의 문장을 반복해서 수행한다. repeat은 다른 언어의 do-while에 해당한다. |

반복문 내 블록에서는 break, next 문을 사용해 반복의 수행을 조정할 수 있다.

**•** **break** : 반복문을 종료한다.

**•** **next** : 현재 수행 중인 반복문 블록의 수행을 중단하고 다음 반복을 시작한다.

다음 코드에서 for 문은 변수 i가 주어진 벡터에 있는 1, 2, 3, …, 10을 차례로 출력한다.

```javascript
> for (i in 1:10) {
+    print(i)
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

다음 while 문은 1부터 10까지 숫자를 출력하기 위해 변수 i의 값을 10과 비교하면서 print( )하는 예다.

```javascript
> i <- 1
> while (i <= 10) {
+    print(i)
+    i <- i + 1
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```

while 문에서 next를 사용해 짝수만 출력해보자. 값이 짝수인지 확인하는 데는 나머지 연산자 %%를 사용했다.

```javascript
> i <- 0
> while (i <= 9) {
+    i <- i + 1
+    if (i %% 2 != 0) {
+       next  # print()를 실행하지 않고 while 문의 처음으로 감
+    }
+    print(i)
+ }
[1] 2
[1] 4
[1] 6
[1] 8
[1] 10
```

다음은 repeat을 사용해서 1부터 10까지 값을 출력한 예다. repeat 문에서 조건을 지정하려면 블록 내부에서 if 문으로 조건을 확인하고 break로 빠져나오도록 해야 한다.

```javascript
> i <- 1
> repeat {
+    print(i)
+    if (i >= 10) {
+       break
+    }
+    i <- i + 1
+ }
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
```



###  연산

#### 수치 연산

지금까지 암시적으로 사용한 사칙 연산(+, -, *, /)을 포함한 수치 연산에 대해 알아보자. 사칙 연산은 다른 언어와 크게 다르지 않지만 약간의 문법적 차이가 있다. 다음 표에 연산자와 함수를 정리했다.

▼ **표 3-4** 수치 연산자와 함수

| 연산자와 함수          | 의미                                                   |
| ---------------------- | ------------------------------------------------------ |
| +, -, *, /             | 사칙 연산                                              |
| n %% m                 | n을 m으로 나눈 나머지                                  |
| n %/% m                | n을 m으로 나눈 몫                                      |
| n^m                    | n의 m승                                                |
| exp(n)                 | e의 n승                                                |
| log(x, base=exp(1))    | logbase(x). 만약 base가 지정되지 않으면 loge(x)를 계산 |
| log2(x), log10(x)      | 각각 log2(x), log10(x)를 계산                          |
| sin(x), cos(x), tan(x) | 삼각 함수                                              |

위 연산자는 다른 프로그래밍 언어와 크게 다른 점은 없지만, 다음 절에서 다룰 벡터 연산을 사용해 다수의 데이터에 연산을 한 번에 수행할 수 있다는 점은 알아둘 만하다. 다음은 1, 2, 3, 4, 5 각각에 2를 곱한 뒤 1을 더한 예다. 각 숫자를 개별적으로 연산하는 것이 아니라 벡터에 통째로 연산자를 적용하고 있음을 눈여겨보기 바란다.

```
> 1:5 \* 2 + 1
[1] 3 5 7 9 11
```

연산에 있어 또 다른 특별한 객체는 행렬이다. 행렬의 연산에 대해서는 ‘2장. 데이터 타입’에서 이미 다뤘다.

#### 벡터 연산

벡터 연산Vectorized Computation(또는 Array Programming)은 벡터 또는 리스트를 한 번에 연산하는 것을 말한다. 벡터 연산이 중요한 이유는 for 문 등을 사용해 값을 하나씩 처리해나가는 대신 벡터나 리스트를 한 번에 처리하는 것이 더 효율적이고 편리하기 때문이다. 가장 간단한 예로 다음과 같이 벡터에 저장된 값을 1씩 증가시키는 경우를 살펴보자.

```
> x <- c(1, 2, 3, 4, 5)
> x + 1
[1] 2 3 4 5 6
```

벡터끼리 연산하는 것도 가능하다. 앞서 ‘2.3.5 진릿값’ 절에서 설명했듯이 벡터 간 연산 시에는 &&가 아니라 &를 사용한다.

```
> x <- c(1, 2, 3, 4, 5)
> x + x
[1] 2 4 6 8 10
> x == x
[1] TRUE TRUE TRUE TRUE TRUE
> x == c(1, 2, 3, 5, 5)
[1] TRUE TRUE TRUE FALSE TRUE
> c(T, T, T) & c(T, F, T)
[1] TRUE FALSE TRUE
```

R의 함수들은 기본적으로 이러한 벡터 기반 연산을 지원한다. 예를 들어, 다음과 같이 sum( ), mean( ), median( ) 등은 벡터를 곧바로 인자로 받을 수 있다.

```
> x <- c(1, 2, 3, 4, 5)
> sum(x)
[1] 15
> mean(x)
[1] 3
> median(x)
[1] 3
```

ifelse( )도 한 번에 적용 가능하다. 다음은 2로 나눈 나머지를 사용해 짝수even, 홀수odd를 판별하는 예다.

```
> x <- c(1, 2, 3, 4, 5)
> ifelse(x %% 2 == 0, "even", "odd")
[1] "odd" "even" "odd" "even" "odd"
```

벡터 연산을 사용하면 데이터 프레임Data Frame에 저장된 데이터 중 원하는 정보를 쉽게 얻을 수 있다. 기본 원리는 데이터 프레임에 진릿값을 지정해 특정 행을 얻어올 수 있다는 점을 이용하는 것이다. 다음은 1행, 3행, 5행에 TRUE를 지정해 해당 행들만 데이터 프레임에서 가져오는 예다.

```
> (d <- data.frame(x=c(1, 2, 3, 4, 5), y=c("a", "b", "c", "d", "e")))
  x y
1 1 a
2 2 b
3 3 c
4 4 d
5 5 e
> d[c(TRUE, FALSE, TRUE, FALSE, TRUE), ]
  x y
1 1 a
3 3 c
5 5 e
```

따라서 행의 선택 기준이 되는 TRUE, FALSE를 벡터 연산으로 만들어주면 특정 행을 선택할 수 있게 된다. 다음은 x 값이 짝수인 행만 선택한 예다.

```
> d[d$x %% 2 == 0, ]
  x y
2 2 b
4 4 d
```

#### NA의 처리

NA는 값이 기록되지 않았거나 관측되지 않은 경우 데이터에 저장되는 값으로 ‘결측치’라고 부른다. 예를 들어, 인구 조사에서 특정 가구가 소득을 묻는 항목에 답을 하지 않았다면 해당 값은 NA로 기록될 것이다.

데이터에 NA가 포함되어 있을 경우 연산 결과가 다음과 같이 NA로 바뀌어버리므로 주의가 필요하다.

```
> NA & TRUE
[1] NA
> NA + 1
[1] NA
```

이러한 문제점을 해결하기 위해 많은 R 함수에서 **na.rm**을 함수 인자로 받는다. na.rm은 NA 값이 있을 때 해당 값을 연산에서 제외할 것인지를 지정하는 데 사용한다. 다음 예를 살펴보자.

```
> sum(c(1, 2, 3, NA))
[1] NA
> sum(c(1, 2, 3, NA), na.rm=TRUE)
[1] 6
```

이처럼 NA 값에 따라 처리를 다르게 하려면 **na.fail, na.omit, na.exclude, na.pass** 함수를 사용한다. 또 다른 예로, 잘 알려진 기계 학습 패키지 중 하나인 caret(Classification and Regression Training)은 NA 처리 방법을 결정한다. 표 3-5에 이 함수들을 보였다.

▼ **표 3-5** NA 처리 함수

| 함수                    | 의미                                                         |
| ----------------------- | ------------------------------------------------------------ |
| na.fail(object, ...)    | object에 NA가 포함되어 있으면 실패한다.                      |
| na.omit(object, ...)    | object에 NA가 포함되어 있으면 이를 제외한다.                 |
| na.exclude(object, ...) | object에 NA가 포함되어 있으면 이를 제외한다는 점에서 na.omit과 동일하다. 그러나 naresid, napredict를 사용하는 함수에서 NA로 제외한 행을 결과에 다시 추가한다는 점이 다르다. |
| na.pass(object, ...)    | object에 NA가 포함되어 있더라도 통과시킨다.                  |

다음 예는 이 함수들의 차이를 보여준다.

```
> (x <- data.frame(a=c(1, 2, 3), b=c("a", NA , "c"), c=c("a", "b", NA)))
  a    b    c
1 1    a    a
2 2 <NA>    b
3 3    c <NA>
> na.fail(x)     # NA가 포함되어 있으므로 실패
Error in na.fail.default(x) : missing values in object
> na.omit(x)     # NA가 포함된 행을 제외
  a b c
1 1 a a
> na.exclude(x)  # NA가 포함된 행을 제외
  a b c
1 1 a a
> na.pass(x)     # NA의 여부에 상관없이 통과
  a    b    c
1 1    a    a
2 2 <NA>    b
3 3    c <NA>
```

따라서 NA를 어떻게 처리할지를 na.action이라는 함수 인자로 받았다면 ‘na.action(데이터 프레임)’을 실행해 현재 처리 중인 데이터를 사용자가 원하는 대로 정제할 수 있다.

*<Note>* na.omit과 na.exclude의 차이

------

다음과 같이 NA가 포함된 데이터 프레임을 가정해보자.

```
  > df <- data.frame(x=1:5, y=seq(2,10,2))
  > df[3, 2]=NA
  > df
  x y
  1 1 2
  2 2 4
  3 3 NA
  4 4 8
  5 5 10
```

이 데이터에 y = ax + b 형태의 선형 모델을 가정해보자. 이 모델은 선형 회귀 함수 lm( )으로 만들 수 있다. 만들어진 모델에 resid( ) 함수를 적용하면 선형 모델로 예측한 값과 실제 y 값 간의 차이인 잔차(residual)를 구할 수 있다(선형 회귀 및 lm, resid 함수 등에 대한 내용은 ‘8장. 선형 회귀’에서 다시 다룬다).

lm( ) 함수는 인자로 na.action을 받으며, 이 값에 따라 NA가 포함된 행을 다루는 방법이 달라진다. 예를 들어, na.omit을 지정하면 다음과 같이 NA가 포함된 3행을 제외하고 모델을 작성한다. 따라서 df에 총 5행이 있지만 resid( )의 결과는 총 4개 값이다.

```
  > resid(lm(y ~ x, data=df, na.action=na.omit))
              1            2            4             5
  -2.982647e-16 3.439354e-16 1.612526e-16 -2.069233e-16
```

반면 na.action에 na.exclude를 지정하면 NA를 제외하고 모델을 만들지만, 잔차(residual)를 구할 때 NA가 포함된 행은 잔차를 NA로 해서 추가한다. 따라서 resid( )의 결과의 길이와 원래 데이터의 길이가 같다.

```
  > resid(lm(y ~ x, data=df, na.action=na.exclude))
              1            2            3             4             5
  -2.982647e-16 3.439354e-16            NA 1.612526e-16 –2.069233e-16
```



### 함수의 정의

#### 기본 정의

함수는 다음과 같은 기본 문법을 사용해 정의한다.

```
function_name <- function(인자, 인자, ...) {
  함수 본문
  return(반환 값)  # 반환 값이 없다면 생략
}
```

예를 들어, 다음은 피보나치 함수를 구현한 예다.

```
> fibo <- function(n) {
+   if (n == 1 || n == 2) {
+     return(1)
+   }
+   return(fibo(n - 1) + fibo(n - 2))
+ }
> fibo(1)
[1] 1
> fibo(5)
[1] 5
```

*<Warning>*

R에서 함수를 정의하는 방법은 이처럼 다른 언어의 함수 정의와 유사하지만 몇 가지 차이점이 있다.

첫째는 값 반환 시 ‘return 반환 값’ 형태가 아니라 함수 호출을 하듯이 **‘return(반환 값)**’ 형태로 작성해야 한다는 점이다.

둘째는 return( )을 생략하면 함수에서 마지막 문장의 반환 값이 함수의 반환 값이 된다는 점이다. 이 점을 이용하면 fibo( ) 함수를 다음과 같이 고쳐 쓸 수 있다.

```javascript
  fibo <- function(n) {
    if (n == 1 || n == 2) {
      1
    } else {
      fibo(n - 1) + fibo(n - 2)
    }
  }
```

그러나 보통은 return( )을 적어주어 코드의 의도를 명확히 한다.

함수를 호출할 때는 인자의 위치를 맞춰서 값을 넘겨주는 방식, 인자의 이름을 지정해서 넘겨주는 방식 두 가지 모두 가능하다. 다음은 이 두 가지 방식을 모두 보여주는 예다.

```javascript
> f <- function(x, y) {
+   print(x)
+   print(y)
+ }
> f(1, 2)      # 인자의 위치에 맞춘 전달
[1] 1
[1] 2
> f(y=1, x=2)  # 인자 이름 지정 방식으로 전달
[1] 2
[1] 1
```

그 외 함수 호출 방법에 대한 다양한 예를 ‘2.2 함수 호출 시 인자 지정’ 절에서 다룬 바 있으니 해당 내용을 참고하기 바란다.



#### 가변 길이 인자

R에서 함수들의 도움말을 살펴보면 ‘…’을 인자 목록에 적은 경우를 종종 볼 수 있다. …은 개수를 알 수 없는 임의의 인자를 표현하는 데 사용하기도 하고, 내부에서 호출하는 다른 함수에 넘겨줄 인자를 표시하는 데도 사용한다.

다음은 가변 인자로 …을 사용한 예다. 함수 f( )에서 …을 인자로 지정한 뒤 이를 하나씩 화면에 출력했다.

```
> f <- function(...) {
+   args <- list(...)
+   for (a in args) {
+     print(a)
+   }
+ }
> f('3', '4')
[1] "3"
[1] "4"
```

다음은 함수 g( )가 인자 z와 …을 인자로 받아서 인자 z는 자신이 처리하고 나머지 인자들은 함수 f로 넘겨 처리하는 예다. 코드에서 f( )를 호출할 때 마치 명시적인 인자를 넘겨주듯이 …을 인자로 지정했다.

```
> f <- function(x, y) {
+   print(x)
+   print(y)
+ }
> g <- function(z, ...) {
+   print(z)
+   f(...)
> g(1, 2, 3)
[1] 1
[1] 2
[1] 3
```

수업시간 예제 

```javascript
f3 <- function(...){
sum <- 0
  for(i in (...)){
   if(i%%2 ==0){
      print(i)
     sum = sum +i
    }
  }
  return(sum)
}

f3(c(1:100))
```

### 스코프

코드에 기술한 이름(예를 들면, 변수명)이 어디에서 사용 가능한지를 정하는 규칙을 스코프Scope라고 한다. R에서는 대부분의 현대적인 프로그래밍 언어가 그러하듯이 문법적 스코프lexical scope(정적 스코프static scope)를 사용하며, 문법적 스코프는 변수가 정의된 블록 내부에서만 변수를 접근할 수 있는 규칙을 말한다.

R의 스코프 규칙을 코드를 통해 알아보자. 예를 들어, 콘솔에서 변수를 선언하면 모든 곳에서 사용 가능한 전역 변수가 된다. 이 변수는 현재 실행 중인 R 세션 동안 유효하다. 따라서 코드를 여러 파일에 나눠놓고 source( )를 사용해 실행할 경우 다른 파일에서도 해당 변수를 사용할 수 있다.[**2**](https://thebook.io/006723/ch03/05/#footnote-96400-2)

다음은 콘솔에서 변수 n을 선언한 다음, 이 변수를 함수 내부에서 사용한 예다.

```
> n <- 1
> f <- function() {
+    print(n)
+ }
> f()
[1] 1
> n <- 2
> f()
[1] 2
```

만약 함수 내부에서 전역 변수와 같은 이름의 지역 변수를 사용하면, 함수 내부의 지역 변수가 우선한다.

```
> n <- 100
> f <- function() {
+    n <- 1
+    print(n)
+ }
> f()
[1] 1
```

만약 함수 내부에서도, 전역 변수로도 선언되지 않은 이름을 사용하면 에러다. 이를 살펴보기에 앞서 R 객체를 메모리에서 삭제하거나 객체를 나열하는 함수들에 대해 살펴보자.

▼ **표 3-6** 메모리상의 객체 관련 함수

| rm : 지정한 환경[**3**](https://thebook.io/006723/ch03/05/#footnote-96400-3)에서 객체를 삭제한다. |
| ------------------------------------------------------------ |
| `rm(   ...,                       # 삭제할 객체의 목록   list=character(),          # 삭제할 객체를 나열한 벡터   envir=as.environment(pos)  # 객체를 삭제할 환경 )` |
| ls : 객체를 나열한다.                                        |
| `ls(   name, # 객체를 나열할 환경의 이름   envir # name 대신 직접 환경을 지정할 경우 사용 )`반환 값은 객체 이름의 문자열 벡터다. |

따라서 rm(list=ls( ))는 메모리에 있는 모든 객체를 삭제하는 명령이 된다. 다음은 rm(list=ls( ))를 사용해 메모리에 존재하는 객체들을 삭제하여 앞서 예제에서 선언한 n을 없앤 다음, 함수 f( )에서 n을 출력해본 예다.

```
> rm(list = ls())
> f <- function() {
+ print(n)
+ }
> f()
Error in print(x) : object 'n' not found
```

------

**2** ‘1.6 배치 실행’ 절에서 source( )에 대해 설명했다.

**3** 환경(environment)은 명명된 객체(named object)를 나열한 프레임(frame), 해당 환경을 감싸고 있는 또 다른 환경(enclosing environment)으로 구성된다. 환경을 사용하면 호출된 함수(callee)가 호출한 쪽(caller)의 변수를 조작하는 등의 작업을 할 수 있다



변수는 내부 블록에서만 접근할 수 있으므로 함수 내부에 정의한 이름은 함수 바깥에서 접근할 수 없다.

```
> rm(list = ls())
> f <- function() {
+ n <- 1
+ }
> f()
> n
Error : object 'n' not found
```

함수 내에서 이름은 함수 안의 변수들로부터 먼저 찾는다. 같은 이유로 함수 인자의 변수명 역시 전역 변수보다 우선한다.

```
> n <- 100
> f <- function(n) {
+ print(n)
+ }
> f(1)
[1] 1
```

중첩 함수에도 같은 규칙이 적용된다. 다음 코드에서 함수 g( ) 안에는 변수 a가 선언되어 있지 않다. 따라서 R 언어는 g( ) 함수를 감싼 함수 f( )로부터 변수 a를 찾는다.

```
> f <- function(x) {
+   a <- 2
+   g <- function(y) {
+     print(y + a)
+   }
+   g(x)
+ }
> f(1)
[1] 3
```

그러나 만약 함수 f( )마저도 변수 a를 포함하고 있지 않다면 전역 변수 a를 사용하게 된다.

```
> a <- 100
> f <- function(x) {
+   g <- function(y) {
+   print(y + a)
+   }
+   g(x)
+ }
> f(1)
[1] 101
```

내부 블록에서 외부 블록에 선언된 값을 수정하고자 할 때는 주의가 필요하다. 내부 블록이 외부 블록보다 우선하므로 <-를 사용한 값의 할당 시, 값이 할당되는 대상이 내부 블록으로 간주되기 때문이다. 예를 들어, 함수 f( ) 안에 변수 a가 있고 중첩된 함수 g( )에서 함수 f( ) 안의 변수 a에 값을 할당하려고 하는 다음 코드를 살펴보자.

```
> f <- function() {
+   a <- 1
+   g <- function() {
+     a <- 2
+     print(a)
+   }
+   g()
+   print(a)
+ }
> f()
[1] 2
[1] 1
```

이 코드에서는 함수 g( )에서 함수 f( )에 선언된 변수 a에 2를 할당하려 했지만 <-는 함수 g( ) 내부에 새로운 변수 a를 만들고 해당 변수에 2를 할당한다. 따라서 f( )에서 print(a)가 수행될 때 출력은 2가 아니라 1이 된다. 만약 함수 g에서 함수 f( ) 안의 변수 또는 전역 변수에 값을 할당하려면 <<-를 사용해야 한다.

```
> b <- 0
> f <- function() {
+   a <- 1
+   g <- function() {
+     a <<- 2
+     b <<- 2
+     print(a)
+     print(b)
+   }
+   g()
+   print(a)
+   print(b)
+ }
> f()
[1] 2
[1] 2
[1] 2
[1] 2
```

실행 결과 g( ) 안에서 <<-를 사용한 값의 할당은 함수 f( )에 선언된 a와 전역 변수인 b를 대상으로 이루어졌음을 볼 수 있다.





### 값에 의한 전달

R에서는 모든 것이 객체다. 또, 객체는 함수 호출 시 일반적으로 값으로 전달된다. 이를 변수에 대한 참조Reference에 의한 방식에 대비해 값에 의한 전달Pass By Value이라고 한다. 값으로 전달된다는 말은 객체가 복사되어 함수로 전달된다는 의미다.

여기에는 예외(환경Environment, 심볼Symbol, 스페셜Special, 빌트인Builtin 등)도 있다. 그러나 이들에 대한 내용은 이 책의 범위를 벗어나므로 관심 있는 독자는 참고자료 [[2\]](https://thebook.io/006723/ch03/09/#ref2)를 확인하기 바란다. 이 책에서 다루는 범위 안에서는 객체가 값으로 넘어간다고 간주해도 좋다.

값으로 데이터가 넘어가는 예를 살펴보자. 예를 들어, 다음과 같이 데이터 프레임을 함수에 인자로 주었을 때 함수 내부에서 수행한 변경은 원래 객체에 반영되지 않는다. 왜냐하면 함수 f( ) 안에서 df2란 f( )를 호출한 쪽에서 넘긴 객체를 가리키는 참조가 아니라 넘겨받은 df를 복사한 새로운 데이터 프레임이기 때문이다.

```
> f <- function(df2) {
+ df2$a <- c(1, 2, 3)
+ }
> df <- data.frame(a=c(4, 5, 6))
> f(df)
> df
a
1 4
2 5
3 6
```

만약 인자로 받은 df를 수정하고 이를 함수를 호출한 쪽에 반영하려면 함수 f에서 수정된 값을 반환하고 함수를 호출한 쪽에서 원래 변수에 할당해야 한다.

```
> f <- function(df) {
+ df$a <- c(1, 2, 3)
+ return(df)
+ }
> df <- data.frame(a=c(4, 5, 6))
> df <- f(df)  # df의 값을 덮어쓴다.
> df
a
1 1
2 2
3 3
```

결과적으로 특별한 객체(예를 들면, 네트워크 접속connection이나 파일 입출력 등)를 제외하고는 객체의 상태가 함수에 의해 직접 수정되지 않는다. 이런 이유로 어떤 함수를 호출하더라도 인자로 넘긴 객체가 수정되지 않음을 보장받는다. 이 주제에 더 관심 있는 독자는 <Mutable objects in R>[[3\]](https://thebook.io/006723/ch03/09/#ref3)을 참고하기 바란다.

*<Note>* 쓰기 시 복사(Copy on Write 또는 Copy on Modify)

------

여기까지 읽은 독자는 ‘그렇다면 객체가 함수에 넘겨질 때마다 새로운 객체를 만들어야 하니 메모리 사용량이 너무 많아지지 않을까?’ 또는 ‘매번 새로운 객체를 만들려면 속도가 느려지지 않을까?’ 의심을 품게 될 것이다. 실제로 매번 복사가 일어나야 한다면 이러한 부담이 있는 것이 사실이다.

그러나 R을 포함한 현대적 언어는 함수 호출 시 곧바로 객체를 복사하기보다는 객체의 값을 바꿀 필요가 있을 때만 복사를 수행하는 ‘쓰기 시 복사(Copy On Write)’ 기법을 사용한다. 쓰기 시 복사에서는 데이터 프레임 등의 객체를 어떤 함수에 넘겼을 때 해당 함수가 객체 내부 값을 바꾸는 시점에 이르러서야 값이 수정된 새로운 복사본을 만든다. 따라서 읽기 작업만 수행할 때는 복사에 따른 오버헤드를 염려하지 않아도 된다.



### 객체의 불변성

R의 객체는 (거의 대부분의 경우에) 불변immutable이다.[4] 객체 지향 프로그래밍OOP, Object Oriented Programming에 친숙하지 않은 독자라면, 객체라는 용어는 R에서 메모리에 할당된 데이터 구조들을 뜻한다고 생각하면 된다. 예를 들어, 벡터를 하나 메모리에 만들었으면 그것이 객체고, 리스트를 하나 만들었어도 객체다.

프로그래밍에서 값이 불변이란 말은 수정하는 것이 불가능하다는 뜻이다. 따라서 a라는 리스트 객체를 수정하는 것처럼 보이는 다음 코드는 실제로는 a 객체를 변경하는 것이 아니다.

```
> a <- list()
> a$b <- c(1, 2, 3)
```

코드를 보면 리스트 a에 새로 필드 b를 만들고 거기에 c(1, 2, 3)을 할당하는 수정처럼 보인다. 그러나 실제로 일어나는 일은 a를 복사한 새로운 객체 a′을 만들고, 이 a′에 필드 b를 추가하고 해당 필드에 c(1, 2, 3)을 채워넣은 다음, 변수명 a가 a′을 가리키도록 하는 것이다.

그림 3-1을 살펴보자. 최초의 변수 a는 어떤 객체에 붙여진 이름이었다. 그러나 그 객체의 값을 바꾸면 이전 객체는 버려지며 새로이 a′=c(1, 2, 3)을 담고 있는 새로운 객체가 만들어지고, a는 이 새로운 객체의 이름이 된다.

▼ **그림 3-1** 객체의 불변성![그림 3-1 객체의 불변성](https://thebook.io/img/006723/115.jpg)

이를 직접 코드로 확인해보자. 메모리를 추적하기 위해 먼저 다음 두 가지 함수를 알아둘 필요가 있다.

▼ **표 3-7** 객체의 복사 추적 관련 함수

| tracemem : 객체의 복사를 추적한다.          |
| ------------------------------------------- |
| `tracemem(   x  # 추적할 R 객체 )`          |
| untracemem : 객체 복사 추적을 중단한다.     |
| `untracemem(   x  # 추적을 중단할 R 객체 )` |

다음은 tracemem( )을 사용하여 리스트 a를 추적하게 한 다음, 리스트 a의 값을 수정하자 a가 복사됨을 보여준다.

```
> a <- list()
> tracemem(a)
[1] "<0x081cd534>"
> a$b <- c(1, 2, 3)  # 메모리 복사가 발생해 0x07e73df4 주소에 객체가 새로 만들어짐
tracemem[0x081cd534 -> 0x07e73df4]:
> untracemem(a)
```

‘2.4 벡터’ 절에서 벡터 연산을 설명하면서 벡터 기반 연산을 사용하는 것이 for 등의 반복문을 사용하는 것보다 효율적이라고 한 바 있다. 그 이유 중 하나가 바로 객체가 불변이라는 점이다. 예를 들어, for 문 안에서 벡터의 인자를 하나씩 바꾸는 다음 코드는 v[i] 값을 1씩 증가시킬 때마다 i번째 값이 수정된 벡터를 매번 새로 만들어 v에 할당한다. 따라서 새로운 객체 1,000개를 생성하는 비효율이 발생한다.

```
> v <- 1:1000
> for (i in 1:1000) {
+ v[i] <- v[i] + 1  # i 번째 값을 바꿀 때마다 새로운 벡터가 생성된다!
+ }
```

반면 같은 일을 하는 다음 코드는 v 안에 있는 전체 값을 1만큼 증가시킨 객체를 한 개 만든 다음, 이를 v에 할당한다.

```
> v <- 1:1000
> v <- v + 1
```

이처럼 벡터 연산이 더 빠른 이유는 이러한 메모리 사용 최적화 문제와도 관련이 있다. 메모리 문제를 확인하는 한 가지 방법은 다음 코드를 실행해보는 것이다.

```
> rm(list = ls())  # 메모리에 있는 객체들을 삭제
> gc()             # 가비지 컬렉션(Garbage Collection)4을 수행해 사용하지 않는 메모리를 해제
> v <- 1:99999999
> for (i in 1:99999999) {
+   for (j in 1:99999999) {
+     v[j] <- v[j] + 1
+   }
+ }
```

위 코드를 실행하고 for 문이 수행되는 동안 작업 관리자를 살펴보면 메모리 사용량이 서서히 증가함을 알 수 있다.

------

**4** 가비지 컬렉션(쓰레기 수집으로도 번역됨)은 사용이 종료된 객체가 사용하고 있던 메모리를 자동으로 해제하는 기법이다.

### 큐

큐Queue는 먼저 들어온 데이터를 먼저 처리FIFO, First In First Out하는 데 사용하는 자료 구조다. 큐는 사람들이 차례로 줄을 서 있고, 줄의 제일 앞에 서 있는 사람부터 자기 일을 처리하는 모습을 연상하면 된다. 새로 도착한 사람은 줄의 맨 뒤에 서서 기다린다.

큐는 다음 세 가지 함수로 구현한다.

**•** Enqueue : 줄의 맨 뒤에 데이터를 추가한다.

**•** Dequeue : 줄의 맨 앞에 있는 데이터를 가져온다. 가져온 데이터는 줄에서 빠진다.

**•** Size : 줄의 길이, 즉 자료 구조 내에 저장된 데이터의 수를 반환한다.

이 세 가지 함수를 지원하는 큐를 작성해보자.

```
> q <- c()
> q_size <- 0
> enqueue <- function(data) {
+ q <<- c(q, data)
+ q_size <<- q_size + 1
+ }
> dequeue <- function() {
+ first <- q[1]
+ q <<- q[-1]
+ q_size <<- q_size - 1
+ return(first)
+ }
> size <- function() {
+ return(q_size)
+ }
```

위 코드에서 큐에 저장될 데이터는 벡터 q를 사용해 저장하고 있다. q_size는 큐에 저장된 데이터 수를 기록하는 목적으로 사용한다.

함수 enqueue( )는 q에 이미 저장되어 있는 데이터에 인자로 받은 데이터를 추가하여 다시 변수 q에 할당한다. 이때 <<-를 사용해 전역 변수에 있는 q를 직접 접근하게 했다. 마지막으로 q_size의 값을 1 증가시킨다.

함수 dequeue( )는 q에 저장된 데이터 중 첫 번째 요소를 first에 저장하고, q에는 이 데이터를 제외한 데이터를 저장한 다음 first를 반환한다. 이때 q_size가 1 감소한다.

함수 size( )는 q의 길이인 q_size를 반환한다.

위 코드는 다음과 같이 사용할 수 있다.

```
> enqueue(1)        # 1이 줄의 끝에 선다.
> enqueue(3)        # 3이 줄의 끝에 선다.
> enqueue(5)        # 5가 줄의 끝에 선다.
> print(size())     # 줄의 길이는 3이다.
[1] 3
> print(dequeue())  # 첫 번째로 대기 중인 데이터인 1을 가져온다.
[1] 1
> print(dequeue())  # 두 번째로 대기 중인 데이터인 3을 가져온다.
[1] 3
> print(dequeue())  # 세 번째로 대기 중인 데이터인 5를 가져온다.
[1] 5
> print(size())     # 데이터가 없어 크기가 0이다.
[1] 0
```





## 데이터 조작 I: 벡터 기반 처리와 외부 데이터 처리

R에서는 주로 벡터 기반으로 데이터를 처리한다. 벡터 기반 처리는 개별 요소를 for 루프 등으로 하나씩 처리하는 방식보다 빠르게 수행될 뿐만 아니라 손쉽게 병렬화가 가능하다. 이 장에서는 이러한 벡터 기반 처리를 돕는 R의 기본 함수들을 설명할 것이다. 이러한 함수는 데이터 처리를 위한 핵심적인 함수다. 앞으로 보게 될 대부분의 R 코드에서 이 함수들을 사용하고 있을 것이다. 따라서 이 함수들의 사용법을 잘 아는 것이 R 코드를 작성하고 이해하는 데 중요한 역할을 한다.



### 아이리스 데이터

본격적으로 데이터 조작을 알아보기에 앞서, 앞으로 데이터 처리 및 기계 학습 기법의 예제로 사용할 아이리스(붓꽃)iris 데이터 셋에 대해 살펴보자. 아이리스는 통계학자인 피셔Fisher[**1**](https://thebook.io/006723/ch04/01/#footnote-101232-1) 가 소개한 데이터로, 붓꽃의 3가지 종(setosa, versicolor, virginica)에 대해 꽃받침sepal과 꽃잎petal의 길이를 정리한 데이터다. 이 데이터는 R에 기본으로 내장되어 있고, 이해하기 쉬우며 크기가 작고 기계 학습에서 인기 있는 분야 중 하나인 분류Classification에 적합한 데이터다. 이런 이유로 아이리스는 R뿐만 아니라 다른 데이터 분석이나 기계 학습 관련 라이브러리에서 자주 사용되고 있으므로 이 데이터를 알아두는 것 자체가 큰 의미가 있다.

▼ **표 4-1** 아이리스 데이터

| 컬럼명       | 의미                                                        | 데이터 타입 |
| ------------ | ----------------------------------------------------------- | ----------- |
| Species      | 붓꽃의 종. setosa, versicolor, virginica 세 가지 값 중 하나 | Factor      |
| Sepal.Width  | 꽃받침의 너비                                               | Number      |
| Sepal.Length | 꽃받침의 길이                                               | Number      |
| Petal.Width  | 꽃잎의 너비                                                 | Number      |
| Petal.Length | 꽃잎의 길이                                                 | Number      |

iris에는 붓꽃의 종별로 50행씩, 총 150개 행이 저장되어 있다.



```
> head(iris)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1         5.1         3.5         1.4         0.2   setosa
2         4.9         3.0         1.4         0.2   setosa
3         4.7         3.2         1.3         0.2   setosa
4         4.6         3.1         1.5         0.2   setosa
5         5.0         3.6         1.4         0.2   setosa
6         5.4         3.9         1.7         0.4   setosa
> str(iris)
'data.frame':    150 obs. of 5 variables:
 $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
```

iris에는 붓꽃 데이터가 데이터 프레임으로 저장되어 있는 반면, iris3에는 3차원 배열 형태로 저장되어 있다.

```
> iris3
, , Setosa

     Sepal L.  Sepal W.  Petal L.  Petal W.
[1,]     5.1       3.5       1.4       0.2
[2,]     4.9       3.0       1.4       0.2
...

, , Versicolor

     Sepal L.  Sepal W.  Petal L.  Petal W.
[1,]     7.0       3.2       4.7       1.4
[2,]     6.4       3.2       4.5       1.5
...

, , Virginica

     Sepal L.  Sepal W.  Petal L.  Petal W.
[1,]     6.3       3.3       6.0       2.5
[2,]     5.8       2.7       5.1       1.9
...
```



이외에도 R에는 다양한 데이터 셋이 준비되어 있다. datasets 패키지에 있는 데이터 셋은 R에 기본적으로 포함된 데이터들이며, 이 데이터의 목록은 **library(help=datasets)** 명령으로 살펴볼 수 있다.



### CSV 파일 입출력

CSV 파일을 데이터 프레임으로 읽으려면 read.csv( )를, 데이터 프레임을 CSV로 저장하려면 write.csv( )를 사용한다. 다음 표에 이 함수들의 프로토타입을 보였다.

▼ **표 4-3** CSV 파일 입출력 함수

| read.csv : CSV 파일을 데이터 프레임으로 읽어들인다.          |
| :----------------------------------------------------------- |
| read.csv(<br/>  file,          # 파일명<br/>  header=FALSE,  # 파일의 첫 행을 헤더로 처리할 것인지 여부<br/>  # 데이터에 결측치가 포함되어 있을 경우 R의 NA에 대응시킬 값을 지정한다.<br/>  # 기본값은 "NA"로, "NA"로 저장된 문자열들은 R의 NA로 저장된다.<br/>  na.strings="NA",<br/>  # 문자열을 팩터로 저장할지 또는 문자열로 저장할지 여부를 지정하는 데 사용한다. 별다른<br/>  # 설정을 하지 않았다면 기본값은 보통 TRUE다.<br/>  stringsAsFactors=default.stringsAsFactors()<br/>)<br/>반환 값은 데이터 프레임이다. |
| 반환 값은 데이터 프레임이다.<br />write.csv : 데이터 프레임을 CSV로 저장한다. |
| `write.csv(   x, # 파일에 저장할 데이터 프레임 또는 행렬   file="",        # 데이터를 저장할 파일명   row.names=TRUE  # TRUE면 행 이름을 CSV 파일에 포함하여 저장한다. )` |

read.csv( ), write.csv( )를 사용한 파일 입출력을 알아보자. 다음과 같은 a.csv 파일이 있다고 하자.

```
id,name,score
1,"Mr. Foo",95
2,"Ms. Bar",97
3,"Mr. Baz",92
```

이 파일의 첫 행은 열의 이름이다. read.csv( )를 사용해 파일을 읽어보자.

```
> (x <- read.csv("a.csv"))
  id    name score
1  1 Mr. Foo    95
2  2 Ms. Bar    97
3  3 Mr. Baz    92
> str(x)
'data.frame':    3 obs. of 3 variables:
 $ id   : int  1 2 3
 $ name : Factor w/ 3 levels "Mr. Baz","Mr. Foo",..: 2 3 1
 $ score: int  95 97 92
```

보다시피 읽어들인 파일은 데이터 프레임으로 반환된다.

b.csv 파일에는 다음과 같이 헤더 행이 없다고 가정해보자.

```
1,"Mr. Foo",95
2,"Ms. Bar",97
3,"Mr. Baz",92
```

이 경우에는 다음과 같이 header=FALSE를 지정한다. 헤더가 없어 컬럼의 이름이 주어지지 않게 되므로, 다음 예에서 보인 바와 같이 names( )를 사용해 별도로 컬럼 이름을 지정해야 한다.

```
> (x <- read.csv("b.csv"))
 X1 Mr..Foo X95
1 2 Ms. Bar 97
2 3 Mr. Baz 92
> names(x) <- c("id", "name", "score")
> x
 id name score
1 2 Ms. Bar 97
2 3 Mr. Baz 92
> str(x)
'data.frame':   2 obs. of 3 variables:
 $ id   : int 2 3
 $ name : Factor w/ 2 levels "Mr. Baz","Ms. Bar": 2 1
 $ score: int  97 92
```

위에서 데이터를 읽어들인 결과를 보면 name 컬럼이 모두 팩터 형태로 변환되었다. 그러나 이름은 범주형 변수가 아니므로 다음과 같이 다시 문자열로 변환해줘야 한다.

```
> x$name <- as.character(x$name)
> str(x)
'data.frame': 3 obs. of 3 variables:
 $ id : int 1 2 3
 $ name : chr "Mr. Foo" "Ms. Bar" "Mr. Baz"
 $ score: int 95 97 92
```

또는 처음부터 문자열을 팩터가 아니라 문자열 타입으로 읽도록 stringsAsFactors=FALSE를 지정해도 된다.

```
> x <- read.csv("a.csv", stringsAsFactors=FALSE)
> str(x)
'data.frame':    3 obs. of 3 variables:
 $ id   : int  1 2 3
 $ name : chr "Mr. Foo" "Ms. Bar" "Mr. Baz"
 $ score: int 95 97 92
```



### 객체의 파일 입출력

데이터를 다양한 알고리즘으로 장시간 처리한 뒤 파일에 저장해두면 나중에 같은 계산을 반복할 필요가 없어 효율적이다. 바이너리 파일로 R 객체를 저장하고 불러들이는 함수에는 save( ), load( )가 있다.

```javascript
v1 <- c(1:10)
save(v1,file = "v1.dat")
rm(list=ls())
load("v1.dat")
```



▼ **표 4-4** 객체의 파일 입출력 함수

| save : 메모리에 있는 객체를 파일에 저장한다.                 |
| ------------------------------------------------------------ |
| `save(   ...,               # 저장할 객체의 이름   list=character(),  # 저장할 객체의 이름을 벡터로 지정할 경우 ... 대신 사용   file               # 파일명 )` |
| load : 파일로부터 객체를 메모리로 읽어들인다.                |
| `load(   file  # 파일명 )`반환 값은 파일에서 읽어들인 객체의 이름들을 저장한 벡터다. |

다음은 두 벡터 x, y를 xy.RData 파일에 저장하는 예다.

```
> x <- 1:5
> y <- 6:10
> save(x, y, file="xy.RData")
```

메모리에 있는 모든 객체를 저장하고자 한다면 메모리에 있는 객체 목록을 조회하는 함수 ls( )[**2**](https://thebook.io/006723/ch04/02/02/#footnote-101232-2)의 결과를 list 인자에 지정할 수 있다. 다음은 a, b, c 객체를 파일 abc.RData에 저장하는 예다.

```
> rm(list=ls())  # 메모리에 있는 객체를 모두 삭제
> a <- 1:5
> b <- 6:10
> c <- 11:15
> save(list=ls(), file="abc.RData")
```

파일로부터 데이터를 불러들이는 함수는 load( )다. 다음 코드는 abc.RData 파일로부터 a, b, c 객체를 불러들이는 예를 보여준다.

```
> rm(list=ls())
> ls()
character(0)
> load("abc.RData")
> ls()
[1] "a" "b" "c"
> a
[1] 1 2 3 4 5
> b
[1] 6 7 8 9 10
> c
[1] 11 12 13 14 15
```



## 데이터 프레임의 행과 컬럼 합치기

rbind( )와 cbind( )는 각각 행 또는 컬럼 형태로 주어진 벡터, 행렬, 데이터 프레임을 합쳐서 결과로 행렬 또는 데이터 프레임을 만드는 데 사용한다. 이들 함수는 분리되어 저장된 데이터를 합치는 데 유용하게 사용할 수 있다.

```javascript
x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F)

x$age <- c(20,30)
y <- rbind(x,c(1,"c",40))
y[4,] <- c(1,"d",50)

z<- cbind(y,level=c(1,2,3),bo=c("a","b","c"))
#cbind 하면 컬럼이름이 같더라도 Append됨
```



▼ **표 4-5** 행, 컬럼 병합 함수

| 함수       | 의미                                      |
| ---------- | ----------------------------------------- |
| rbind(...) | 지정한 데이터들을 행으로 취급해 합친다.   |
| cbind(...) | 지정한 데이터들을 컬럼으로 취급해 합친다. |

예를 들어, c(1, 2, 3), c(4, 5, 6)이라는 두 벡터는 rbind( )를 사용해 각 벡터를 한 행으로 하는 행렬로 합칠 수 있다.

```
> rbind(c(1, 2, 3), c(4, 5, 6))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
```

마찬가지로 데이터 프레임 역시 rbind( )를 사용하여 행을 합칠 수 있다. 다음은 2개 행을 저장한 데이터 프레임 x와 새로운 값을 저장한 벡터 c(3, “c”)를 rbind( )로 합쳐서 새로운 데이터 프레임 y에 저장하는 예다.

```
> (x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F))
  id  name
1  1     a
2  2     b
> str(x)
'data.frame':    2 obs. of 2 variables:
 $ id  : num  1 2
 $ name: chr "a" "b"
> (y <- rbind(x, c(3, "c")))
  id  name
1  1     a
2  2     b
3  3     c
```

위 코드의 첫 행에서 stringsAsFactors는 name 컬럼의 데이터를 팩터가 아니라 문자열로 취급하기 위해 필요하다. 만약 stringsAsFactors를 지정하지 않으면 “a”, “b”가 팩터 데이터로 취급되어 이름을 표현하려는 컬럼의 목적에 어긋나게 된다.



##  apply 계열 함수

R에는 벡터, 행렬 또는 데이터 프레임에 임의의 함수를 적용한 결과를 얻기 위한 apply 계열 함수가 있다. 이 함수들은 데이터 전체에 함수를 한 번에 적용하는 벡터 연산을 수행하므로 속도가 빠르다. 다음은 apply 계열 함수를 요약한 것이다.

▼ **표 4-6** apply 계열 함수

| 함수      | 설명                                                         | 다른 함수와 비교했을 때의 특징        |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| apply( )  | 배열 또는 행렬에 주어진 함수를 적용한 뒤 그 결과를 벡터, 배열 또는 리스트로 반환 | 배열 또는 행렬에 적용                 |
| lapply( ) | 벡터, 리스트 또는 표현식에 함수를 적용하여 그 결과를 리스트로 반환 | 결과가 리스트                         |
| sapply( ) | lapply와 유사하지만 결과를 벡터, 행렬 또는 배열로 반환       | 결과가 벡터, 행렬 또는 배열           |
| tapply( ) | 벡터에 있는 데이터를 특정 기준에 따라 그룹으로 묶은 뒤 각 그룹마다 주어진 함수를 적용하고 그 결과를 반환 | 데이터를 그룹으로 묶은 뒤 함수를 적용 |
| mapply( ) | sapply의 확장된 버전으로, 여러 개의 벡터 또는 리스트를 인자로 받아 함수에 각 데이터의 첫째 요소들을 적용한 결과, 둘째 요소들을 적용한 결과, 셋째 요소들을 적용한 결과 등을 반환 | 여러 데이터를 함수의 인자로 적용      |



### apply()

apply( )는 행렬의 행 또는 열 방향으로 특정 함수를 적용하는 데 사용한다.

▼ **표 4-7** apply( ) 함수

| apply : 배열 또는 행렬에 함수 FUN을 MARGIN 방향으로 적용하여 결과를 벡터, 배열 또는 리스트로 반환한다. |
| ------------------------------------------------------------ |
| apply(<br/>  X,       # 배열 또는 행렬<br/>  MARGIN,  # 함수를 적용하는 방향. 1은 행 방향, 2는 열 방향<br/>  # c(1, 2)는 행과 열 방향 모두를 의미<br/>  FUN      # 적용할 함수<br/>)<br/>반환 값은 FUN이 길이 1인 벡터들을 반환한 경우 벡터, 1보다 큰 벡터들을 반환한 경우 행렬, 서로 다른 길이의 벡터를 반환한 경우 리스트다. |

apply( )가 적용된 결과가 벡터, 배열, 리스트 중 어떤 형태로 반환될 것인지는 데이터 X의 데이터 타입과 함수 FUN의 반환 값에 따라 대부분 자연스럽게 예상할 수 있으므로, 반환 값의 데이터 타입에 대해 크게 걱정할 필요는 없다. 또, 반환 값을 str( )로 검토하면 데이터 타입을 알아낼 수 있다는 점을 기억하기 바란다.

합을 구하는 함수 sum( )을 apply( )에 적용하는 예에 대해 알아보자. sum( )은 인자로 주어진 값들의 합을 구하는 간단한 함수다. 예를 들어, 다음은 1부터 10까지의 합을 계산한다.

```
> sum(1:10)
[1] 55
```

이를 사용해 apply( )로 행렬에 저장된 데이터의 합을 구해보자. 예를 들어, 다음과 같은 행렬이 있다고 하자.

```
> d <- matrix(1:9, ncol=3)
> d
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
```

이 행렬의 각 행의 합(즉, 1+4+7, 2+5+8, 3+6+9)을 구하려면 apply를 행별로(즉, MARGIN에 1을 지정) 처리하되 각 행에 대해 sum 함수를 호출하면 된다.

```
> apply(d, 1, sum)
[1] 12 15 18
```

마찬가지로 열 방향 합(1+2+3, 4+5+6, 7+8+9)은 MARGIN=2를 지정해 구한다.

```
> apply(d, 2, sum)
[1] 6 15 24
```



### lapply()

lapply( )는 리스트를 반환하는 특징이 있는 apply 계열 함수다.

▼ **표 4-9** lapply( ) 및 그 결과를 처리하기 위한 함수

| lapply : 벡터, 리스트, 표현식, 데이터 프레임 등에 함수를 적용하고 그 결과를 리스트로 반환한다. |
| ------------------------------------------------------------ |
| `lapply(   X,    # 벡터, 리스트, 표현식 또는 데이터 프레임   FUN,  # 적용할 함수   ...   # 추가 인자. 이 인자들은 FUN에 전달된다. )`반환 값은 X와 같은 길이의 리스트다. |

리스트보다는 벡터 또는 데이터 프레임이 사용하기에 직관적인 면이 있으므로 lapply( )의 결과를 벡터 또는 데이터 프레임으로 변환할 필요가 있다. 이 경우 다음과 같은 함수를 사용한다.

▼ **표 4-10** 리스트를 다른 데이터 타입으로 변환하는 함수

| unlist : 리스트 구조를 벡터로 변환한다.                      |
| ------------------------------------------------------------ |
| `unlist(   x,                # R 객체. 보통 리스트 또는 벡터   recursive=FALSE,  # x에 포함된 리스트 역시 재귀적으로 변환할지 여부   use.names=TRUE    # 리스트 내 값의 이름을 보존할지 여부 )`반환 값은 벡터다. |
| do.call : 함수를 리스트로 주어진 인자에 적용하여 결과를 반환한다. |
| `do.call(   what,  # 호출할 함수   args,  # 함수에 전달할 인자의 리스트 )`반환 값은 함수 호출 결과다. |

c(1, 2, 3) 벡터가 있을 때, 각 숫자를 2배한 값을 lapply( )를 통해 구해보자. 앞서 ‘2.5 리스트’ 절에서 살펴봤듯이, 리스트의 각 값은 형태로 접근한다는 점을 기억하기 바란다(이때 n은 접근할 요소의 색인이다).

```
> (result <- lapply(1:3, function(x) { x*2 }))
1
[1] 2

2
[1] 4

3
[1] 6

> result1
[1] 2
```

위의 예처럼 lapply( )의 결과는 리스트다. 이 결과를 다시 벡터로 변환하고 싶다면 unlist( )를 사용한다.

```
> unlist(result)
[1] 2 4 6
```





### sapply()

sapply( )는 lapply( )와 유사하지만 리스트 대신 행렬, 벡터 등의 데이터 타입으로 결과를 반환하는 특징이 있는 함수다.

▼ **표 4-11** sapply( ) 함수

| sapply : 벡터, 리스트, 표현식, 데이터 프레임 등에 함수를 적용하고 그 결과를 벡터 또는 행렬로 반환한다. |
| ------------------------------------------------------------ |
| `sapply(   X,    # 벡터, 리스트, 표현식 또는 데이터 프레임   FUN,  # 적용할 함수   ...,  # 추가 인자. 이 인자들은 FUN에 전달된다. )`반환 값은 FUN의 결과가 길이 1인 벡터들이면 벡터, 길이가 1보다 큰 벡터들이면 행렬이다. |

예를 들어, 아이리스의 컬럼별로 평균을 구하는 경우를 살펴보자. 다음 코드에서 볼 수 있듯이 lapply( )는 결과를 리스트로 반환하지만, sapply( )는 벡터를 반환한다.

```
> lapply(iris[, 1:4], mean)
$Sepal.Length
[1] 5.843333

$Sepal.Width
[1] 3.057333

$Petal.Length
[1] 3.758

$Petal.Width
[1] 1.199333
> sapply(iris[, 1:4], mean)
Sepal.Length  Sepal.Width  Petal.Length  Petal.Width
    5.843333     3.057333      3.758000     1.199333
> class(sapply(iris[, 1:4], mean))  # "numeric"은 숫자를 저장한 벡터를 의미함
[1] "numeric"
```

sapply( )에서 반환한 벡터는 as.data.frame( )을 사용해 데이터 프레임으로 변환할 수 있다. 이때 t(x)를 사용해 벡터의 행과 열을 바꿔주지 않으면 기대한 것과 다른 모양의 데이터 프레임을 얻게 된다. 다음은 아이리스의 컬럼별 평균을 sapply( )를 사용해 벡터로 구한 뒤 이를 다시 데이터 프레임으로 변환하는 예다.

```
> x <- sapply(iris[, 1:4], mean)
> as.data.frame(x)
                    x
Sepal.Length 5.843333
Sepal.Width  3.057333
Petal.Length 3.758000
Petal.Width  1.199333
> as.data.frame(t(x))
  Sepal.Length  Sepal.Width  Petal.Length  Petal.Width
1     5.843333     3.057333       3.758       1.199333
```

다수의 컬럼을 포함하는 데이터 프레임을 처리하다 보면 종종 각 컬럼의 데이터 타입을 알아내고 싶을 때가 있다. 예를 들면, 어떤 컬럼에 숫자가 저장되어 있는지를 판단하는 경우다. 이때 sapply( )를 유용하게 사용할 수 있다. 다음은 아이리스 데이터에서 각 컬럼의 데이터 타입을 구하는 예다.

```
> sapply(iris, class)
Sepal.Length  Sepal.Width  Petal.Length  Petal.Width   Species
   "numeric"    "numeric"     "numeric"    "numeric"   "factor"
```



### tapply()

tapply( )는 그룹별로 함수를 적용하기 위한 apply 계열 함수다.

▼ **표 4-12** tapply( ) 함수

| tapply : 벡터 등에 저장된 데이터를 주어진 기준에 따라 그룹으로 묶은 뒤 각 그룹에 함수를 적용하고 그 결과를 반환한다. |
| ------------------------------------------------------------ |
| `tapply(   X,      # 벡터   INDEX,  # 데이터를 그룹으로 묶을 색인. 팩터를 지정해야 하며 팩터가 아닌 타입이 지정되면           # 팩터로 형 변환된다.   FUN,    # 각 그룹마다 적용할 함수   ...,    # 추가 인자. 이 인자들은 FUN에 전달된다. )`반환 값은 배열이다. |

다음과 같은 예를 생각해보자. 1부터 10까지의 숫자가 있고 이들이 모두 한 그룹에 속해 있을 때, 이 그룹에 속한 데이터의 합을 구하면 55가 될 것이다.

```
> tapply(1:10, rep(1, 10), sum)
 1
55
```

위 코드에서 rep(1, 10)은 1을 10회 반복하는 것을 의미한다. 따라서 숫자 1, 2, 3, …, 10에 대해 동일한 소속 번호 1, 1, 1, …, 1을 부여한 것이다. 그러므로 그룹 1에 속한 데이터의 합은 55(=1+2+3+…+10)다.



이번에는 1부터 10까지의 숫자를 홀수별, 짝수별로 묶어서 합을 구해보자. INDEX에 홀수와 짝수별로 다른 팩터 값이 주어지도록 %% 2[**4**](https://thebook.io/006723/ch04/04/04-1/#footnote-101232-4)를 사용했다.

```
> tapply(1:10, 1:10 %% 2 == 1, sum)
FALSE TRUE
   30   25
```

수행 결과 짝수의 합이 30(=2+4+6+8+10), 홀수의 합이 25(=1+3+5+7+9)로 구해졌다. 아이리스 데이터에서 Species별 Sepal.Length의 평균을 구해보자.

```
> tapply(iris$Sepal.Length, iris$Species, mean)
    setosa versicolor virginica
     5.006      5.936     6.588
```

이번에는 조금 더 복잡한 그룹화를 다뤄보자. 계절별 성별로 정리된 판매량 데이터가 다음과 같이 주어졌다고 하자.

```
> m <- matrix(1:8,
+             ncol=2,
+             dimnames=list(c("spring", "summer", "fall", "winter"),
+                           c("male", "female")))
> m
        male female
spring     1      5
summer     2      6
fall       3      7
winter     4      8
```

행렬의 행은 봄, 여름, 가을, 겨울을 뜻하고 열은 성별을 의미한다. 이때 반기별, 성별 셀의 합을 구해보자. 즉, 상반기(봄, 여름)의 남성 셀 합(=1+2)과 여성 셀 합(=5+6), 하반기(가을, 겨울)의 남성 셀 합(=3+4)과 여성 셀 합(=7+8)을 구하는 것이 목표다.

이 연산을 수행하기 위한 성별, 분기별 그룹은 다음과 같이 구성할 수 있다. 그림에서 (n, m) 값은 tapply( )에 INDEX로 주어질 값들을 의미한다.

▼ **표 4-13** 성별, 분기별 그룹을 위한 INDEX

|        | male   | female |        |      |
| ------ | ------ | ------ | ------ | ---- |
| spring | (1, 1) | 1      | (1, 2) | 5    |
| summer | (1, 1) | 2      | (1, 2) | 6    |
| fall   | (2, 1) | 3      | (2, 2) | 7    |
| winter | (2, 1) | 4      | (2, 2) | 8    |

INDEX를 실제로 지정할 때는 (n, m)에서 n을 먼저 나열한 뒤 m 값을 나열한다. 즉, 그룹 (n1, m1), (n2, m2)는 list(c(n1, n2), c(m1, m2))로 표현한다. 다음은 이러한 방식으로 tapply( )를 사용한 분기별, 성별 합을 구한 예다.

```
> tapply(m, list(c(1, 1, 2, 2, 1, 1, 2, 2),
+                   c(1, 1, 1, 1, 2, 2, 2, 2)), sum)
  1 2
1 3 11
2 7 15
```

tapply( )는 클러스터링 알고리즘을 수행한 후 같은 클러스터에 속한 데이터들의 x 좌표의 평균, y 좌표의 평균을 계산하는 데 사용할 수 있는데, 바로 이때 위와 같은 방식으로 색인을 부여한다. 따라서 조금 복잡해 보여도 여기서 배운 내용을 꼭 알고 넘어가도록 하자.

------

**4** %%는 나머지를 구하는 연산자다. 몫은 %/%로 구할 수 있다.



### mapply()

이제 apply( ) 계열 함수의 마지막 변형으로 mapply( )에 대해 살펴보자. mapply( )는 sapply( )와 유사하지만 다수의 인자를 함수에 넘긴다는 점에서 차이가 있다. 주요 사용 목적은 다수의 인자를 받는 함수 FUN( )이 있고 FUN( )에 넘겨줄 인자들이 데이터로 저장되어 있을 때, 데이터에 저장된 값들을 인자로 하여 함수를 호출하는 것이다. 다음 표에 mapply( )에 대해 보였다.

▼ **표 4-14** mapply( ) 함수

| mapply : 함수에 리스트 또는 벡터로 주어진 인자를 적용한 결과를 반환한다. |
| ------------------------------------------------------------ |
| `mapply(   FUN,  # 실행할 함수   ...,  # 적용할 인자 )`...에 주어진 여러 데이터가 있을 때 FUN에 이들 데이터 각각의 첫째 요소를 인자로 전달하여 실행한 결과, 각각의 둘째 요소를 인자로 전달하여 실행한 결과 등을 반환한다. |

여기에서는 정규 분포를 따르는 난수를 생성하는 rnorm( ) 함수에 mapply( )를 적용하는 예를 살펴볼 것이다. R에는 다양한 난수 생성 함수가 있다. 이 함수들은 ‘r{분포명}( )’ 형태를 띤다.

▼ **표 4-15** 난수 생성 함수

| 함수                    | 의미                                                         |
| ----------------------- | ------------------------------------------------------------ |
| rnorm(n, mean=0, sd=1)  | 평균이 n, 표준 편차가 sd인 정규 분포를 따르는 난수 n개 발생  |
| runinf(n, min=0, max=1) | 최솟값이 min, 최댓값이 max인 균등 분포를 따르는 난수 n개 발생 |
| rpois(n, lambda)        | 람다 값이 lambda인 포아송 분포를 따르는 난수 n개 발생        |
| rexp(n, rate=1)         | 람다가 rate인 지수 분포를 따르는 난수 n개 발생               |



##  데이터 정렬

이 절에서는 데이터를 정렬하는 함수인 sort( )와 order( )를 설명한다. sort( )는 주어진 데이터를 직접 정렬해주는 함수며, order( )는 데이터를 정렬했을 때의 순서를 반환한다.



### sort()

sort( )는 주어진 벡터를 정렬한 결과를 반환한다.

▼ **표 4-25** sort( ) 함수

| sort : 벡터를 정렬한다.                                      |
| ------------------------------------------------------------ |
| `sort(   x,                 # 정렬할 벡터   decreasing=FALSE,  # 내림차순 여부   # na.last는 NA 값을 정렬한 결과의 어디에 둘 것인지를 제어한다. na.last=TRUE는 NA 값을   # 정렬한 결과의 마지막에 두고, na.last=FALSE는 정렬한 값의 처음에 둔다.   # 기본값인 na.last=NA는 NA 값을 정렬 결과에서 제외한다.   na.last=NA )`반환 값은 정렬된 벡터다. |

다음은 임의의 값이 저장된 벡터를 각각 오름차순과 내림차순으로 정렬한 예다.

```
> x <- c(20, 11, 33, 50, 47)
> sort(x)
[1] 11 20 33 47 50
> sort(x, decreasing=TRUE)
[1] 50 47 33 20 11
> x
[1] 20 11 33 50 47
```

위 코드에서 알 수 있듯이, sort( )는 값을 정렬한 결과를 반환할 뿐이지 인자로 받은 벡터 자체를 변경하지는 않는다. 이는 ‘3.6 값에 의한 전달’ 절에 설명했듯이 R 함수는 대부분 인자를 값으로 전달하기 때문이다.



### order()

order( )는 주어진 인자를 정렬하기 위한 각 요소의 색인을 반환한다. 함수 프로토타입은 ‘4.5.2 orderBy( )’ 절에서 이미 보였으므로 생략한다.

다음은 임의의 값을 저장한 벡터 x를 정렬하기 위한 순서를 반환한 예다. order(x)는 x[order(x)]가 정렬되어 있게 하기 위한 색인이다.

```
> x <- c(20, 11, 33, 50, 47)
> order(x)
[1] 2 1 3 5 4
```

내림차순으로 정렬한 결과를 얻고 싶다면 decreasing=TRUE를 지정한다.

```
> x <- c(20, 11, 33, 50, 47)
> order(x, decreasing=TRUE)
[1] 4 5 3 1 2
```

order( )가 정렬된 순서를 반환한다는 점을 이용해 데이터 프레임을 정렬할 수 있다. 다음은 아이리스 데이터를 Sepal.Length에 따라 정렬한 예다.

```
> iris[order(iris$Sepal.Length), ]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
14          4.3          3.0         1.1         0.1  setosa
9           4.4          2.9         1.4         0.2  setosa
39          4.4          3.0         1.3         0.2  setosa
43          4.4          3.2         1.3         0.2  setosa
42          4.5          2.3         1.3         0.3  setosa
4           4.6          3.1         1.5         0.2  setosa
...
```

결과를 보면 9행, 39행, 43행의 Sepal.Length가 모두 같다. 이와 같이 Sepal.Length가 같을 경우 Petal.Length의 순서에 따라 정렬하려면 다음과 같이 Petal.Length를 추가적인 인자로 order( )에 넘기면 된다.

```
> iris[order(iris$Sepal.Length, iris$Petal.Length), ]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
14          4.3         3.0          1.1         0.1  setosa
39          4.4         3.0          1.3         0.2  setosa
43          4.4         3.2          1.3         0.2  setosa
9           4.4         2.9          1.4         0.2  setosa
42          4.5         2.3          1.3         0.3  setosa
23          4.6         3.6          1.0         0.2  setosa
...
```

보다시피 9행, 39행, 43행이었던 순서가 Petal.Length의 크기에 따라 39행, 43행, 9행으로 바뀌었다.



## 그룹별 연산

doBy가 데이터를 그룹별로 나눈 후 특정 계산을 적용하기 위한 함수들의 패키지인 반면 aggregate( )는 좀 더 일반적인 그룹별 연산을 위한 함수다. aggregate( )를 사용하면 데이터를 그룹으로 묶은 후 임의의 함수를 그룹에 적용할 수 있다.

▼ **표 4-31** 그룹별 연산

| aggregate : 데이터를 분할하고 각 그룹마다 요약치를 계산한다. |
| ------------------------------------------------------------ |
| `aggregate(   x, # R 객체   by, # 그룹으로 묶을 값의 리스트   FUN # 그룹별로 요약치 계산에 사용할 함수 )  aggregate(   formula, # y ~ x 형태로 y는 계산에 사용될 값이며, x는 그룹으로 묶을 때 사용할 기준값   data, # formula를 적용할 데이터   FUN )`입력이 데이터 프레임인 경우, 반환 값은 그룹 값과 그룹의 요약치를 저장한 데이터 프레임이다. |

이 절에서는 aggregate( )에 포뮬러를 적용한 형태의 예를 살펴본다. 다음은 아이리스 데이터에서 종별 Sepal.Width의 평균 길이를 구하는 예다.

```
> aggregate(Sepal.Width ~ Species, iris, mean)
     Species Sepal.Width
1     setosa       3.428
2 versicolor       2.770
3  virginica       2.974
```

같은 일을 tapply( )를 통해서 수행하면 다음과 같다.

```
> tapply(iris$Sepal.Length, iris$Species, mean)
   setosa versicolor virginica
    5.006      5.936     6.588
```

얻는 결과는 같지만 포뮬러를 사용한 aggregate( ) 쪽이 코드 작성하기 편리하다.





## sqldf

```javascript
install.pakages("sqldf")
```

메모리에 데이터를 올리고 sql문으로 분석 가능

```javascript
#titanic r08-1
library(sqldf)
tt <- read.csv("titanic.csv",
               header= TRUE,
               stringsAsFactors = FALSE,
               na.strings = "NA",
)
#get survival rate per classes
result <- sqldf('select pclass, avg(survived) from tt group by pclass')
result
tt
View(tt)
result1 <- sqldf('select pclass,sex, age, avg(survived) from tt group by pclass,age')
result1

result2 <- sqldf('select pclass,sex,avg(survived) as survival_rate from tt group by pclass,sex having avg(survived) <0.5')
result2

class(result2)
```



## 그래프 그리기(ggplot2)

```javascript
#패키지 인스톨
install.pakages("ggplot2")

#실행 
g1() 
```

```javascript
g1 <- function(){
  library(ggplot2);
  x <- c("a","a","b","c","e");
  
    #막대 그래프 생성
    qplot(x);
}
```









Summary

R Variable

1. scalar

2. Factor 
3. **Vector** (한가지 타입)
4. List
5. Matrix 
6. **Data** **Frame** \

R Function

R Programming 

1. 





# 오류

1. csv 파일이 Rstudio내에서 꺠져서 보일때 (csv 파일 저장할때 ANSI 말고 UTF-8로 저장)
   
- 그냥 저장할때 엑셀파일 이용하거나 하셈
   
2. 잘라낸 데이터 타입이 Data Frame 일 경우 mean 연산이 안되므로 타입 캐스팅이 필요함.

3. SQL문을 쓸때 컬럼명에 . 이포함되면 못읽을 수 있으니 바깥쪽을 single quatation, 컬럼명을 double quatation을 써서 처리

   ```javascript
   result <- sqldf('select Species,avg("Sepal.Length"),avg("Sepal.Width") from iris group by Species')
   ```

   